{"pages":[],"posts":[{"title":"Biject Inside","text":"题目地址又是想了很久也没做出来，写下官方题解吧。 题意A随机选择1 ~ n的一个排列$p$，B随机选择1 ~ n的一个子集$S$，如果存在$1\\leq i \\leq n$，使得$i,p_i$都在$S$中，A就赢了。问A赢的概率。 题解给定一个排列$p$，要求有哪些集合使得A能赢是困难的，因为这和具体的排列有关。可以反过来，即给定$B$的集合$S$，求有多少种排列能让A赢，这个数只和$|S|$有关，因此容易处理。下面先计算使A输的情况，因为这容易算。假设$S$的大小为$k$，令$i=S_j$，其中$1\\leq j \\leq k$。那么$p_i$不能取$S$中的元素，只能从剩下的$n-k$个元素中选。这样的数量为$A_{n-k}^k$。剩下的$n-k$个$i$对应的$p_i$可以随便选，为$(n-k)!$，因此一个大小为$k$的集合让A输的排列有$A_{n-k}^k(n-k)!$种。再考虑到大小为$k$的集合有$C_{n}^k$个，最后对$k$求和，总数为：$$\\displaystyle\\sum_{k=0}^n C_{n}^kA_{n-k}^k(n-k)!=n!\\sum_{k=0}^nC_{n-k}^k$$需要计算$\\sum_{k=0}^nC_{n-k}^k\\triangleq g(n)$，这实际上和Fibonacci数有关。下面证明。证明考虑由0,1构成的n位字符串的数量，其中没有两个1相邻。 证明第一部分首先证明这是Fibonacci数。用$f_{n}$表示$n$位的数量，$f_{n,0}$表示0结尾的答案，$f_{n,1}$表示1结尾的答案。显然$$f_{n,0}=f_{n-1}\\f_{n,1}=f_{n-1,0}$$相加得：$f_n=f_{n-1}+f_{n-1,0}=f_{n-1}+f_{n-2}$而$f_1=2,f_2=3$如果按Fibonacci数的定义，就有$f_n=F_{n+2}$。 证明第二部分计算有$k$个1的串的数量：那么有$n-k$个0，算上两端有$n-k+1$个隔板，把$k$个1放入隔板中，有$C_{n-k+1}^k$中方法。枚举$k$，总数为$\\sum_{k=0}^nC_{n-k+1}^k=g(n+1)$。即$g(n)=F_{n+1}$QED.","link":"/2019/07/24/Biject Inside/"},{"title":"","text":"题目地址 题意核心问题是，给定一个长为$N$的01串，连续子串中1的数量大于等于子串长度一半（向下取整）的为合法串。问合法串的最大长度。 解法$N\\leq 10^5$，因此需要$n\\log n$的算法。我原以为这个长度会满足单调性，即如果长的串满足，短的一定满足。其实不对。反例：$10001$整个串满足条件，但找不到长度为4的合法串。下面给出官方题解。用$f$表示累积和序列，那么原条件可表示为：$$f(R)-f(L-1)\\geq \\frac{R-L+1}{2} \\quad(1)$$这个条件可以等价表示为$$f(R)-f(L-1)\\geq \\frac{R-L}{2.0} \\quad(2)$$证明(1)-&gt;(2)因为$\\frac{R-L+1}{2}\\geq \\frac{R-L}{2.0}$（可根据$R-L$的奇偶讨论）。(2)-&gt;(1)当$R-L$为偶数时，$\\frac{R-L}{2.0}=\\frac{R-L+1}{2}$。当$R-L$为奇数时，因为$f(R)-f(L-1)$为整数，(2)实际上是$f(R)-f(L-1)\\geq \\frac{R-L}{2.0}+0.5$。证毕。 (2)可变为$$2f(R)-R\\geq 2f(L-1)-L$$那么可形成两个这样的序列：$$p(i)=2f(i)-i\\q(i)=2f(i-1)-i$$对于每个$R$，计算最小的满足$p(R)\\geq q(L)$的$L$。当然这里要用二分来计算$L$，否则就没有意义了。然而$q$并不是一个单调序列。实际上不需要完整的$q$序列，因为如果$i&lt;j$，且$q(i)&lt;q(j)$的话，计算$L$时肯定不会选到$j$。因此只要从$i=1$开始，形成一个单调递减序列$q’$就行了。$q’[i].index=j$，$q’[i].value = q[j]$。官方的程序用了一个比较聪明的做法，可以不用结构体。使用原序列的长度，如果下一个元素比现在的大，那么下一个元素变为与现在的一样大，那么在二分时会得到正确的结果。","link":"/2019/07/24/Superior Substring/"},{"title":"","text":"序列用$A$表示，处理到当前元素为止，长度为$i$的子序列的最小的结尾元素用$B_i$表示。序列$B$是单调增的，即$$B_i&lt;B_j \\quad \\text{if}\\quad i&lt;j$$因为如果$B_i\\geq B_j$，那么$B_j$对应的子序列中的第$i$个数是小于$B_i$的，这与$B_i$是最小的矛盾。假设当前LIS长度为$L$，现在要计算以$A_k$结尾的LIS，只需二分长度$l$，看是否满足$B_l&lt;A_k$。假设以$A_k$结尾的LIS长度为$m$，再进行一次更新： 12B[m] = min(B[m], A[k]);L = max(L, m); 即可。","link":"/2019/07/24/最长上升子序列(LIS)的nlogn算法/"}],"tags":[],"categories":[]}