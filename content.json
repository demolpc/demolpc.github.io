{"pages":[],"posts":[{"title":"EM算法","text":"EM算法就是含有隐变量的概率模型参数的极大似然估计法（或极大后验概率估计法）用$x$表示观测变量（的数据），$z$表示隐变量，$\\theta$表示需要估计的模型参数。给定观测数据$x$，其似然函数为$p(x|\\theta)$，对数似然函数$L(\\theta) \\triangleq \\ln p(x|\\theta)$。极大似然估计：$$\\max_{\\theta}L(\\theta)$$ EM算法算法是迭代进行的，假设第$n$轮迭代得到的参数估计为$\\theta_n$，希望下一轮迭代使得$L(\\theta)&gt;L(\\theta_n)$$$\\begin{aligned}L(\\theta)-L(\\theta_n) &amp;=\\ln \\left(\\sum_zp(x,z|\\theta)\\right)-\\ln p(x|\\theta_n)\\\\end{aligned}$$对数函数是凹函数，满足Jensen不等式：$$\\log \\left(\\sum_j\\lambda_jy_j\\right)\\geq \\sum_j \\lambda_j\\log y_j$$其中$\\lambda_j\\geq 0, \\sum_j\\lambda_j=1$那么$$\\begin{aligned}L(\\theta)-L(\\theta_n) &amp;=\\ln \\left(\\sum_zp(z|x,\\theta_n)\\frac{p(x,z|\\theta)}{p(z|x,\\theta_n)}\\right)-\\ln p(x|\\theta_n)\\&amp;\\geq \\sum_zp(z|x,\\theta_n)\\ln\\frac{p(x,z|\\theta)}{p(z|x,\\theta_n)}-\\ln p(x|\\theta_n)\\&amp;=\\sum_zp(z|x,\\theta_n)\\ln\\frac{p(x,z|\\theta)}{p(z|x,\\theta_n)}-\\left(\\sum_zp(z|x,\\theta_n)\\right)\\ln p(x|\\theta_n)\\&amp;=\\sum_zp(z|x,\\theta_n)\\ln\\frac{p(x,z|\\theta)}{p(z,x|\\theta_n)}\\end{aligned}$$即：$$\\begin{aligned}L(\\theta)&amp;\\geq L(\\theta_n)+\\sum_zp(z|x,\\theta_n)\\ln\\frac{p(x,z|\\theta)}{p(z,x|\\theta_n)}\\&amp;\\triangleq B(\\theta,\\theta_n)\\end{aligned}$$也就是$B(\\theta,\\theta_n)$是$L(\\theta)$的一个下界函数。而且容易看到：$$B(\\theta_n,\\theta_n) = L(\\theta_n)$$即自变量等于$\\theta_n$时，两个函数值是相等的。那么如果找一个$\\theta_{n+1}$，使得$B(\\theta_{n+1},\\theta_n)\\geq B(\\theta_n,\\theta_n)$，那么$$\\begin{aligned}L(\\theta_{n+1})&amp;\\geq B(\\theta_{n+1},\\theta_n)\\&amp;\\geq B(\\theta_n,\\theta_n)\\&amp;=L(\\theta_n)\\end{aligned}$$一种方法是使：$$\\theta_{n+1}=\\operatorname{argmax} B(\\theta,\\theta_n)$$但是注意这样并不能保证$L(\\theta)$的增长也能极大化，这和$L(\\theta)$的具体形状有关。容易看出，使$B(\\theta,\\theta_n)$极大化，等价于极大化下面的式子$$Q(\\theta,\\theta_n)\\triangleq \\sum_zp(z|x,\\theta_n)\\ln p(x,z|\\theta)$$这个式子有着鲜明的含义：当有了$x,\\theta$，根据$z$的概率分布$p(z|x,\\theta_n)$可以采样出$z$，这样就有了完整的数据，可以做平常的极大似然估计。因此EM算法的步骤是：E步：求完整数据对数似然的期望，这个期望是在概率分布$p(z|x,\\theta_n)$下求的。M步：极大化，只是保证$L(\\theta)$增大的一种方式。 在E步中，$\\ln p(x,z|\\theta)$应该是很好算的，$p(z|x,\\theta)$也好算：$$p(z|x,\\theta)=\\frac{p(x,z|\\theta)}{p(x|\\theta)}=\\frac{p(x,z|\\theta)}{\\sum_{z’}p(x,z’|\\theta)}$$","link":"/2019/07/24/EM算法/"},{"title":"Biject Inside","text":"题目地址又是想了很久也没做出来，写下官方题解吧。 题意A随机选择1 ~ n的一个排列$p$，B随机选择1 ~ n的一个子集$S$，如果存在$1\\leq i \\leq n$，使得$i,p_i$都在$S$中，A就赢了。问A赢的概率。 题解给定一个排列$p$，要求有哪些集合使得A能赢是困难的，因为这和具体的排列有关。可以反过来，即给定$B$的集合$S$，求有多少种排列能让A赢，这个数只和$|S|$有关，因此容易处理。下面先计算使A输的情况，因为这容易算。假设$S$的大小为$k$，令$i=S_j$，其中$1\\leq j \\leq k$。那么$p_i$不能取$S$中的元素，只能从剩下的$n-k$个元素中选。这样的数量为$A_{n-k}^k$。剩下的$n-k$个$i$对应的$p_i$可以随便选，为$(n-k)!$，因此一个大小为$k$的集合让A输的排列有$A_{n-k}^k(n-k)!$种。再考虑到大小为$k$的集合有$C_{n}^k$个，最后对$k$求和，总数为：$$\\displaystyle\\sum_{k=0}^n C_{n}^kA_{n-k}^k(n-k)!=n!\\sum_{k=0}^nC_{n-k}^k$$需要计算$\\sum_{k=0}^nC_{n-k}^k\\triangleq g(n)$，这实际上和Fibonacci数有关。下面证明。证明考虑由0,1构成的n位字符串的数量，其中没有两个1相邻。 证明第一部分首先证明这是Fibonacci数。用$f_{n}$表示$n$位的数量，$f_{n,0}$表示0结尾的答案，$f_{n,1}$表示1结尾的答案。显然$$f_{n,0}=f_{n-1}\\f_{n,1}=f_{n-1,0}$$相加得：$f_n=f_{n-1}+f_{n-1,0}=f_{n-1}+f_{n-2}$而$f_1=2,f_2=3$如果按Fibonacci数的定义，就有$f_n=F_{n+2}$。 证明第二部分计算有$k$个1的串的数量：那么有$n-k$个0，算上两端有$n-k+1$个隔板，把$k$个1放入隔板中，有$C_{n-k+1}^k$中方法。枚举$k$，总数为$\\sum_{k=0}^nC_{n-k+1}^k=g(n+1)$。即$g(n)=F_{n+1}$QED.","link":"/2019/07/24/Biject Inside/"},{"title":"Superior Substring","text":"题目地址 题意核心问题是，给定一个长为$N$的01串，连续子串中1的数量大于等于子串长度一半（向下取整）的为合法串。问合法串的最大长度。 解法$N\\leq 10^5$，因此需要$n\\log n$的算法。我原以为这个长度会满足单调性，即如果长的串满足，短的一定满足。其实不对。反例：$10001$整个串满足条件，但找不到长度为4的合法串。下面给出官方题解。用$f$表示累积和序列，那么原条件可表示为：$$f(R)-f(L-1)\\geq \\frac{R-L+1}{2} \\quad(1)$$这个条件可以等价表示为$$f(R)-f(L-1)\\geq \\frac{R-L}{2.0} \\quad(2)$$证明(1)-&gt;(2)因为$\\frac{R-L+1}{2}\\geq \\frac{R-L}{2.0}$（可根据$R-L$的奇偶讨论）。(2)-&gt;(1)当$R-L$为偶数时，$\\frac{R-L}{2.0}=\\frac{R-L+1}{2}$。当$R-L$为奇数时，因为$f(R)-f(L-1)$为整数，(2)实际上是$f(R)-f(L-1)\\geq \\frac{R-L}{2.0}+0.5$。证毕。 (2)可变为$$2f(R)-R\\geq 2f(L-1)-L$$那么可形成两个这样的序列：$$p(i)=2f(i)-i\\q(i)=2f(i-1)-i$$对于每个$R$，计算最小的满足$p(R)\\geq q(L)$的$L$。当然这里要用二分来计算$L$，否则就没有意义了。然而$q$并不是一个单调序列。实际上不需要完整的$q$序列，因为如果$i&lt;j$，且$q(i)&lt;q(j)$的话，计算$L$时肯定不会选到$j$。因此只要从$i=1$开始，形成一个单调递减序列$q’$就行了。$q’[i].index=j$，$q’[i].value = q[j]$。官方的程序用了一个比较聪明的做法，可以不用结构体。使用原序列的长度，如果下一个元素比现在的大，那么下一个元素变为与现在的一样大，那么在二分时会得到正确的结果。","link":"/2019/07/24/Superior Substring/"},{"title":"Yet Again a Subarray Problem","text":"题目 题意给定一个数组$A$，长度$N&lt;2000$，$A_i&lt;2000$。对于它的每个连续子序列，计算这个子序列中第$K$小的数（$K$随子序列而不同，这不是问题重点），记为$x$，得到$x$在子序列中出现的次数$F$。如果$F$在子序列中也出现过，那么答案加一，求总的答案。 题解解法一 线段树对于左端点下标为$i$的子序列，在递增右端点的过程中，可以连续处理。线段树中节点保存的是值在$[l,r]$之间的数在当前子序列中出现的次数，而不是序列中的下标。那么根据左子节点中保存的数和$K$的关系，很容易找到第$K$小的数对应的叶节点，也就得到$F$。然后再看$F$对应的叶节点中保存的出现次数是否为0即可。 解法二 预处理+二分首先预处理得到PRE[x][r]，表示$[1,r]$子序列中$\\leq x$的数的个数。预处理后可以$O(1)$计算$[l,r]$子序列中$\\leq x$的数的个数。二分$x$就可得到第$K$小的数。根据PRE[x][r]也可以$O(1)$得到$[l,r]$子序列中等于$x$的数的个数，因此问题解决。","link":"/2019/07/24/Yet Again a Subarray Problem/"},{"title":"最长上升子序列(LIS)的nlogn算法","text":"序列用$A$表示，处理到当前元素为止，长度为$i$的子序列的最小的结尾元素用$B_i$表示。序列$B$是单调增的，即$$B_i&lt;B_j \\quad \\text{if}\\quad i&lt;j$$因为如果$B_i\\geq B_j$，那么$B_j$对应的子序列中的第$i$个数是小于$B_i$的，这与$B_i$是最小的矛盾。假设当前LIS长度为$L$，现在要计算以$A_k$结尾的LIS，只需二分长度$l$，看是否满足$B_l&lt;A_k$。假设以$A_k$结尾的LIS长度为$m$，再进行一次更新： 12B[m] = min(B[m], A[k]);L = max(L, m); 即可。","link":"/2019/07/24/最长上升子序列(LIS)的nlogn算法/"}],"tags":[],"categories":[]}