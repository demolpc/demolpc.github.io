{"pages":[],"posts":[{"title":"","text":"题目地址 题意核心问题是，给定一个长为$N$的01串，连续子串中1的数量大于等于子串长度一半（向下取整）的为合法串。问合法串的最大长度。 解法$N\\leq 10^5$，因此需要$n\\log n$的算法。我原以为这个长度会满足单调性，即如果长的串满足，短的一定满足。其实不对。反例：$10001$整个串满足条件，但找不到长度为4的合法串。下面给出官方题解。用$f$表示累积和序列，那么原条件可表示为：$$f(R)-f(L-1)\\geq \\frac{R-L+1}{2} \\quad(1)$$这个条件可以等价表示为$$f(R)-f(L-1)\\geq \\frac{R-L}{2.0} \\quad(2)$$证明(1)-&gt;(2)因为$\\frac{R-L+1}{2}\\geq \\frac{R-L}{2.0}$（可根据$R-L$的奇偶讨论）。(2)-&gt;(1)当$R-L$为偶数时，$\\frac{R-L}{2.0}=\\frac{R-L+1}{2}$。当$R-L$为奇数时，因为$f(R)-f(L-1)$为整数，(2)实际上是$f(R)-f(L-1)\\geq \\frac{R-L}{2.0}+0.5$。证毕。 (2)可变为$$2f(R)-R\\geq 2f(L-1)-L$$那么可形成两个这样的序列：$$p(i)=2f(i)-i\\q(i)=2f(i-1)-i$$对于每个$R$，计算最小的满足$p(R)\\geq q(L)$的$L$。当然这里要用二分来计算$L$，否则就没有意义了。然而$q$并不是一个单调序列。实际上不需要完整的$q$序列，因为如果$i&lt;j$，且$q(i)&lt;q(j)$的话，计算$L$时肯定不会选到$j$。因此只要从$i=1$开始，形成一个单调递减序列$q’$就行了。$q’[i].index=j$，$q’[i].value = q[j]$。官方的程序用了一个比较聪明的做法，可以不用结构体。使用原序列的长度，如果下一个元素比现在的大，那么下一个元素变为与现在的一样大，那么在二分时会得到正确的结果。","link":"/2019/07/24/Superior Substring/"}],"tags":[],"categories":[]}