<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="demolpc的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="demolpc的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="demolpc">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>demolpc的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">demolpc的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/03/numpy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="demolpc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="demolpc的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/03/numpy/" class="post-title-link" itemprop="url">numpy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-03 08:27:12" itemprop="dateCreated datePublished" datetime="2019-10-03T08:27:12+08:00">2019-10-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-13 20:31:58" itemprop="dateModified" datetime="2019-10-13T20:31:58+08:00">2019-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ndarray的<code>data</code>在内存中是连续存储的，通过<code>strides</code>属性来将索引映射到存储位置。<code>strides</code>是一个长度为<code>ndim</code>的tuple，表示相应轴上前进一个单位对应内存位置上增加的字节数。如果用<span class="math inline">\((s_1,\dots,s_n)\)</span>表示，索引用<span class="math inline">\(i_1,\dots,i_n\)</span>表示，那么对应的内存字节位置为<span class="math inline">\(\sum_{k=1}^ni_ks_k\)</span>。</p>
<p>有的操作只需要改变<code>strides</code>，引用的还是原来的<code>data</code>，这样的数组称为view。</p>
<p><code>np.full</code>：用任意常数构成数组</p>
<p><code>np.logspace</code>：和<code>linspace</code>类似，只不过是作为指数。</p>
<p><code>numpy.ones_like</code>等函数： 以另一个数组为参数，使得生成的数组有同样的shape和dtype。</p>
<p>通过切片得到的数组是view，因此改变这个数组会改变原数组。如果想要独立的数组，用copy。</p>
<p>fancy indexing：可以用整形数组和列表来作为索引。</p>
<p>还可以用bool数组作为索引，选中为<code>True</code>的位置。</p>
<p>通过fancy indexing和bool数组方式得到的是独立的数组，而不是view。但是可以通过这两种方式来改变数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fancy indexing</span></span><br><span class="line">In [<span class="number">99</span>]: A = np.arange(<span class="number">10</span>)</span><br><span class="line">In [<span class="number">100</span>]: indices = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">In [<span class="number">101</span>]: B = A[indices]</span><br><span class="line">In [<span class="number">102</span>]: B[<span class="number">0</span>] = -<span class="number">1</span> <span class="comment"># this does not affect A</span></span><br><span class="line">In [<span class="number">103</span>]: A</span><br><span class="line">Out[<span class="number">103</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">In [<span class="number">104</span>]: A[indices] = -<span class="number">1</span> <span class="comment"># this alters A</span></span><br><span class="line">In [<span class="number">105</span>]: A</span><br><span class="line">Out[<span class="number">105</span>]: array([ <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Boolean-valued indexing</span></span><br><span class="line">In [<span class="number">106</span>]: A = np.arange(<span class="number">10</span>)</span><br><span class="line">In [<span class="number">107</span>]: B = A[A &gt; <span class="number">5</span>]</span><br><span class="line">In [<span class="number">108</span>]: B[<span class="number">0</span>] = -<span class="number">1</span> <span class="comment"># this does not affect A</span></span><br><span class="line">In [<span class="number">109</span>]: A</span><br><span class="line">Out[<span class="number">109</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">In [<span class="number">110</span>]: A[A &gt; <span class="number">5</span>] = -<span class="number">1</span> <span class="comment"># this alters A</span></span><br><span class="line">In [<span class="number">111</span>]: A</span><br><span class="line">Out[<span class="number">111</span>]: array([ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p><code>reshape</code>创建view。</p>
<p><code>ravel</code>将数组展开成一维，创建view。</p>
<p><code>flatten</code>同样得到一维数组，但是是原数组的copy。</p>
<p>np.newaxis填充一个长度为1的轴。</p>
<h1 id="broadcast">broadcast</h1>
<p>两个数组如果维度不同，则维度较少的那个数组从左边开始填充长度为1的轴。之后两个数组相应轴比较，如果长度相等或者有一个长度为1，则能够应用broadcast。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/21/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="demolpc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="demolpc的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/21/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" class="post-title-link" itemprop="url">支持向量机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-21 11:56:27" itemprop="dateCreated datePublished" datetime="2019-09-21T11:56:27+08:00">2019-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-22 19:44:53" itemprop="dateModified" datetime="2019-09-22T19:44:53+08:00">2019-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="hard-margin">hard-margin</h1>
<h2 id="线性可分">线性可分</h2>
<p>假设数据点是线性可分的，即存在<span class="math inline">\((b,\mathbf{w})\)</span>满足 <span class="math display">\[
y_n(\mathbf{w}^T\mathbf{x}_n+b)&gt;0 \quad n=1,\dots,N
\]</span> <span class="math inline">\((b,\mathbf{w})\)</span>和<span class="math inline">\((\frac{b}{\rho},\frac{\mathbf{w}}{\rho})\)</span>表示同样的超平面。令 <span class="math display">\[
\rho = \min_{n=1,\dots,N}y_n(\mathbf{w}^T\mathbf{x}_n+b)
\]</span> 则对于同样的超平面<span class="math inline">\((b/\rho,\mathbf{w}/\rho)\)</span>，有 <span class="math display">\[
\min_{n=1,\dots,N}y_n\left(\frac{\mathbf{w}^T}{\rho}\mathbf{x}_n+\frac{b}{\rho}\right)=\frac{1}{\rho}\min_{n=1,\dots,N}y_n(\mathbf{w}^T\mathbf{x}_n+b)=\frac{\rho}{\rho}=1
\]</span> 因此可定义超平面<span class="math inline">\(h=(b,\mathbf{w})\)</span>满足 <span class="math display">\[
\min_{n=1,\dots,N}y_n(\mathbf{w}^T\mathbf{x}_n+b)=1
\]</span> 点<span class="math inline">\(\mathbf{x}\)</span>到<span class="math inline">\(h\)</span>的距离为 <span class="math display">\[
d(\mathbf{x},h)=\frac{|\mathbf{w}^T\mathbf{x}+b|}{\|\mathbf{w}\|}
\]</span> 由于<span class="math inline">\(y_n=\pm1\)</span>且线性可分 <span class="math display">\[
|\mathbf{w}^T\mathbf{x}+b|=|y_n(\mathbf{w}^T\mathbf{x}+b)|=y_n(\mathbf{w}^T\mathbf{x}+b)
\]</span> 那么 <span class="math display">\[
d(\mathbf{x}_n,h)=\frac{y_n(\mathbf{w}^T\mathbf{x}_n+b)}{\|\mathbf{w}\|}
\]</span> 所有点到超平面距离的最小值称为<strong>margin</strong>： <span class="math display">\[
\min_{n=1,\dots,N}d(\mathbf{x}_n,h)=\frac{1}{\|\mathbf{w}\|}\cdot\min_{n=1,\dots,N}y_n(\mathbf{w}^T\mathbf{x}_n+b)=\frac{1}{\|\mathbf{w}\|}
\]</span> 我们希望得到margin最大的超平面。让<span class="math inline">\(\frac{1}{\|\mathbf{w}\|}\)</span>最大也就是让<span class="math inline">\(\mathbf{w}^T\mathbf{w}\)</span>最小，因此问题归结于： <span class="math display">\[
\begin{aligned}
\min_{b,\mathbf{w}}&amp;\quad\frac{1}{2}\mathbf{w}^T\mathbf{w}\\
s.t.&amp;\quad\min_{n=1,\dots,N}y_n(\mathbf{w}^T\mathbf{x}_n+b)=1
\end{aligned}
\]</span> ### 求解</p>
<p>为了容易求解，可以把条件 <span class="math inline">\(\min_ny_n(\mathbf{w}^T\mathbf{x}_n+b)=1\)</span> 换成 <span class="math display">\[
y_n(\mathbf{w}^T\mathbf{x}_n+b)\ge1 \quad n=1,\dots,N
\]</span> 这个条件显然比原条件宽松，但是可以证明问题的最优解必然满足<span class="math inline">\(\min_ny_n(\mathbf{w}^T\mathbf{x}_n+b)=1\)</span>。</p>
<p>用反证法。数据中同时存在正类和负类时必有<span class="math inline">\(\mathbf{w}\neq \mathbf{0}\)</span>（否则<span class="math inline">\(b&gt;0\)</span>且<span class="math inline">\(-b&gt;0\)</span>，矛盾）。</p>
<p>假设<span class="math inline">\((b^*,\mathbf{w}^*)\)</span>是问题的最优解，满足 <span class="math display">\[
\rho^*=\min_ny_n(\mathbf{w}^T\mathbf{x}_n+b)&gt;1
\]</span> 考虑<span class="math inline">\((b,\mathbf{w})=\frac{1}{\rho^*}(b^*,\mathbf{w}^*)\)</span>。则<span class="math inline">\(\|\mathbf{w}\|=\frac{1}{\rho^*}\|\mathbf{w}^*\|&lt;\|\mathbf{w}^*\|\)</span>，与<span class="math inline">\((b^*,\mathbf{w}^*)\)</span>是最优解矛盾，得证。</p>
<p>那么问题变为 <span class="math display">\[
\begin{aligned}
\min_{b,\mathbf{w}}&amp;\quad\frac{1}{2}\mathbf{w}^T\mathbf{w}\\
s.t.&amp;\quad y_n(\mathbf{w}^T\mathbf{x}_n+b)\ge1\quad\text{for all } n
\end{aligned}
\label{problem1}\tag{1}
\]</span> 这就是<strong>svm的primal问题</strong>，是个二次规划的问题。</p>
<h4 id="二次规划">二次规划</h4>
<p>标准形式： <span class="math display">\[
\mathbf{u}^*\leftarrow \text{QP}(Q,\mathbf{p},A,\mathbf{c})\\
\begin{aligned}
\min_{\mathbf{u}}&amp;\quad \frac{1}{2}\mathbf{u}^TQ\mathbf{u}+\mathbf{p}^T\mathbf{u}\\
s.t.&amp;\quad \mathbf{a}_m^T\mathbf{u}\ge c_m \quad m=1,\dots,M
\end{aligned}
\]</span> <span class="math inline">\((\ref{problem1})\)</span>可以写成标准形式： <span class="math display">\[
\begin{aligned}
\text{目标函数:}&amp;\quad\mathbf{u}=\begin{bmatrix}
b\\
\mathbf{u}
\end{bmatrix};Q=\begin{bmatrix}
0 &amp; \mathbf{0}_d^T\\
\mathbf{0}_d &amp; I_d
\end{bmatrix};\mathbf{p}=\mathbf{0}_{d+1}\\
\text{约束:}&amp;\quad \mathbf{a}_n^T=y_n\begin{bmatrix}
1 &amp; \mathbf{x}_n^T
\end{bmatrix};c_n=1;M=N
\end{aligned}
\]</span> 其中<span class="math inline">\(d\)</span>为<span class="math inline">\(\mathbf{x}\)</span>的维度。</p>
<p><span class="math inline">\(A=\begin{bmatrix}\mathbf{a}_1^T\\\vdots\\\mathbf{a}_N^T\end{bmatrix}\)</span>与线性规划中的数据矩阵<span class="math inline">\(X\)</span>相似，只不过每行多乘了<span class="math inline">\(y_n\)</span>。</p>
<p>如果<span class="math inline">\(Q\)</span>是半正定的，二次规划是凸的。这里的<span class="math inline">\(Q\)</span>满足条件。</p>
<p>令问题的解为超平面<span class="math inline">\(g=(b^*,\mathbf{w}^*)\)</span>，满足<span class="math inline">\(d(\mathbf{x}_n,g)=\frac{1}{\|\mathbf{w}^*\|}\)</span>的数据点称为<strong>support vector</strong>(candidate)。把支持（或者叫支撑更合适）向量以外的数据点拿掉后，得到的最优分离超平面不会变。</p>
<p>hard margin的意思是超平面到两边margin的范围内没有数据点。</p>
<h2 id="dual">dual</h2>
<p>现在考虑svm的对偶问题，因为在后面使用特征变换时会用到。</p>
<p>定义Lagrange函数： <span class="math display">\[
L(b,\mathbf{w},\alpha)=\frac{1}{2}\mathbf{w}^T\mathbf{w}+\sum_{n=1}^N\alpha_n(1-y_n(\mathbf{w}^T\mathbf{x}_n+b))
\]</span> 那么原问题和以下问题等价， <span class="math display">\[
\min_{b,\mathbf{w}}\left(\max_{\text{all }\alpha_n\ge0}L(b,\mathbf{w},\alpha)\right)
\]</span> 因为如果<span class="math inline">\((b,\mathbf{w})\)</span>不满足条件<span class="math inline">\(y_n(\mathbf{w}^T\mathbf{x}_n+b)\ge1\)</span>，那么<span class="math inline">\(\max_{\alpha_n\ge0}\alpha_n(1-y_n(\mathbf{w}^T\mathbf{x}_n+b))\to\infty\)</span>。反之，如果<span class="math inline">\((b,\mathbf{w})\)</span>满足所有条件，<span class="math inline">\(\max_{\text{all }\alpha_n\ge0}\sum_{n=1}^N\alpha_n(1-y_n(\mathbf{w}^T\mathbf{x}_n+b))=0\)</span>，即<span class="math inline">\(\max_{\text{all }\alpha_n\ge0}L(b,\mathbf{w},\alpha)=\frac{1}{2}\mathbf{w}^T\mathbf{w}\)</span>。</p>
<p>对于任意满足要求的<span class="math inline">\(\alpha&#39;\)</span>，因为<span class="math inline">\(\max_{\text{all }\alpha_n\ge0}L(b,\mathbf{w},\alpha)\ge L(b,\mathbf{w},\alpha&#39;)\)</span>，所以 <span class="math display">\[
\min_{b,\mathbf{w}}\left(\max_{\text{all }\alpha_n\ge0}L(b,\mathbf{w},\alpha)\right)\ge\min_{b,\mathbf{w}}L(b,\mathbf{w},\alpha&#39;)
\]</span> 由于上式对于任意<span class="math inline">\(\alpha&#39;\)</span>都成立，自然应该大于等于其中的最大者，即： <span class="math display">\[
\min_{b,\mathbf{w}}\left(\max_{\text{all }\alpha_n\ge0}L(b,\mathbf{w},\alpha)\right)\ge\max_{\text{all }\alpha&#39;_n\ge0}\min_{b,\mathbf{w}}L(b,\mathbf{w},\alpha&#39;)
\]</span> 右边换用符号<span class="math inline">\(\alpha\)</span>，即 <span class="math display">\[
\min_{b,\mathbf{w}}\left(\max_{\text{all }\alpha_n\ge0}L(b,\mathbf{w},\alpha)\right)\ge\max_{\text{all }\alpha_n\ge0}\left(\min_{b,\mathbf{w}}L(b,\mathbf{w},\alpha)\right)
\]</span> 上式左边为<strong>primal</strong>，右边为<strong>Lagrange dual</strong>。<span class="math inline">\(\ge\)</span>表示weak duality。</p>
<p>对于二次规划，如果满足以下条件：</p>
<ul>
<li>primal是convex的</li>
<li>primal存在可行解</li>
<li>约束是线性的</li>
</ul>
<p>那么<span class="math inline">\(\ge\)</span>可用<span class="math inline">\(=\)</span>取代，称为<strong>strong duality</strong>。</p>
<p>存在<span class="math inline">\((b,\mathbf{w},\alpha)\)</span>，对于两边都是最优解。</p>
<p>求解dual内层： <span class="math display">\[
\frac{\partial L}{\partial b}=0\Rightarrow\sum y_n\alpha_n=0\\
\]</span> <span class="math display">\[
\frac{\partial L}{\partial \mathbf{w}}=\mathbf{0}\Rightarrow\mathbf{w}=\sum \alpha_ny_n\mathbf{x}_n
\label{condition1}\tag{2}
\]</span></p>
<p>代入之后，dual变为： <span class="math display">\[
\max_{\text{all }\alpha\ge0,\sum y_n\alpha_n=0,\mathbf{w}=\sum \alpha_ay_n\mathbf{x}_n}-\frac{1}{2}\left\|\sum_{n=1}^N\alpha_ny_n\mathbf{x}_n\right\|^2+\sum_{n=1}^N\alpha_n
\]</span> 从前面的推导中可见，最优解应满足的（必要）条件有：</p>
<ul>
<li>primal有可行解：<span class="math inline">\(y_n(\mathbf{w}^T\mathbf{x}_n+b)\ge1\)</span></li>
<li>对dual解的限制：<span class="math inline">\(\alpha_n\ge0\)</span></li>
<li>dual内层最优条件：<span class="math inline">\(\sum y_n\alpha_n=0,\mathbf{w}=\sum \alpha_ay_n\mathbf{x}_n\)</span></li>
<li>primal内层最优条件(complementary slackness)：<span class="math inline">\(\alpha_n\left(1-y_n(\mathbf{w}^T\mathbf{x}_n+b)\right)=0 \label{slackness}\tag{3}\)</span></li>
</ul>
<p>这些称为<strong>KKT条件</strong>，这里也是充分条件（<em>如何证明？</em>）</p>
<p>将上式最大转为求最小，并展开第一项，得： <span class="math display">\[
\begin{aligned}
\min_{\alpha}&amp;\quad\frac{1}{2}\sum_{n=1}^N\sum_{m=1}^N\alpha_n\alpha_my_ny_m\mathbf{x}_n^T\mathbf{x}_m-\sum_{n=1}^N\alpha_n\\
s.t.&amp;\quad\sum_{n=1}^Ny_n\alpha_n=0\\
&amp;\quad\alpha_n\ge0\quad n=1,\dots,N
\end{aligned}
\]</span> 这就是<strong>svm的dual问题</strong>。写成二次规划的标准形式： <span class="math display">\[
\begin{aligned}
\min_{\alpha}&amp;\quad\frac{1}{2}\alpha^TQ\alpha-\mathbf{1}_{N}^T\alpha\\
s.t.&amp;\quad A\alpha\ge\mathbf{0}_{N+2}
\end{aligned}
\]</span> 其中 <span class="math display">\[
Q_{n,m}=y_ny_m\mathbf{x}_n^T\mathbf{x}_m\\
A=\begin{bmatrix}
\mathbf{y}^T\\
-\mathbf{y}^T\\
I_{N\times N}
\end{bmatrix}
\]</span> <span class="math inline">\(A\)</span>的前两行是因为<span class="math inline">\(\mathbf{y}^T\alpha=0\)</span>等价于<span class="math inline">\(\mathbf{y}^T\alpha\ge0\)</span>且<span class="math inline">\(\mathbf{y}^T\alpha\le0\)</span>。</p>
<p>可以看到，<span class="math inline">\(Q=X_sX_s^T\)</span>，其中<span class="math inline">\(X_s\)</span>为带符号的数据矩阵： <span class="math display">\[
\begin{aligned}
X_s=\begin{bmatrix}
y_1\mathbf{x}_1^T\\
\vdots\\
y_N\mathbf{x}_N^T
\end{bmatrix}
\end{aligned}
\]</span></p>
<p>因此<span class="math inline">\(Q\)</span>为半正定矩阵，这个二次规划问题是凸的。</p>
<p>要注意<span class="math inline">\(Q\)</span>是<span class="math inline">\(N\times N\)</span>的矩阵，<span class="math inline">\(N\)</span>比较大时占用很大内存，SMO？</p>
<h3 id="恢复svm的解">恢复svm的解</h3>
<p>现已求得最优解<span class="math inline">\(\alpha^*\)</span>，<span class="math inline">\(\mathbf{w}^*\)</span>由<span class="math inline">\((\ref{condition1})\)</span>得出： <span class="math display">\[
\mathbf{w}^*=\sum \alpha_n^*y_n\mathbf{x}_n
\]</span> <span class="math inline">\(\mathbf{w}^*\)</span>是<span class="math inline">\(y_n\mathbf{x}_n\)</span>的线性组合，这和感知机的学习算法的结果相似，称为<span class="math inline">\(\mathbf{w}\)</span>由数据表征。</p>
<p>如果数据中同时有正类和负类，由前面说明过的<span class="math inline">\(\mathbf{w}^*\ne\mathbf{0}\)</span>可知至少存在一个值<span class="math inline">\(\alpha^*_s\ne0\)</span>。那么由<span class="math inline">\((\ref{slackness})\)</span>得： <span class="math display">\[
y_s(\mathbf{w}^{*T}\mathbf{x}_s+b^*)=1
\]</span> 可知<span class="math inline">\((\mathbf{x}_s,y_s)\)</span>属于support vector candidates。</p>
<p>求得： <span class="math display">\[
\begin{aligned}
b^*&amp;=y_s-\mathbf{w}^{*T}\mathbf{x}_s\\
&amp;=y_s-\sum_{n=1}^Ny_n\alpha_n^*\mathbf{x}_n^T\mathbf{x}_s
\end{aligned}
\]</span> 容易看到，<span class="math inline">\(\mathbf{w}^{*}\)</span>和<span class="math inline">\(b^*\)</span>可以只用<span class="math inline">\(\alpha_n^*&gt;0\)</span>对应的数据点得到，这些数据点称为support vector。</p>
<h2 id="kernel-trick">kernel trick</h2>
<p>如果在<span class="math inline">\(\mathbf{x}\)</span>空间中不是线性可分，考虑特征变换：<span class="math inline">\(\mathbf{z}=\Phi(\mathbf{x})\)</span>，看在<span class="math inline">\(\mathbf{z}\)</span>空间中能否做得更好。设<span class="math inline">\(\mathbf{x}\)</span>的维度为<span class="math inline">\(d\)</span>，<span class="math inline">\(\mathbf{z}\)</span>的维度为<span class="math inline">\(\tilde{d}\)</span>。计算<span class="math inline">\(Q_{n,m}=y_ny_m\mathbf{z}_n^T\mathbf{z}_m\)</span>复杂度为<span class="math inline">\(O(\tilde{d})\)</span>。需要降低计算<span class="math inline">\(\mathbf{z}_n^T\mathbf{z}_m=\Phi(\mathbf{x}_n)^T\Phi(\mathbf{x}_m)\)</span>的复杂度。</p>
<p>二阶多项式变换：<span class="math inline">\(\Phi_2(\mathbf{x})=(1,x_1,x_2,\dots,x_d,x_1x_1,x_1x_2,\dots,x_dx_d)\)</span>，这里为了后面推导方便，同时包含了<span class="math inline">\(x_ix_j\)</span>和<span class="math inline">\(x_jx_i\)</span>。 <span class="math display">\[
\begin{aligned}
\Phi_2(\mathbf{x})^T\Phi_2(\mathbf{x}&#39;)&amp;=1+\sum_{i=1}^dx_ix_i&#39;+\sum_{i=1}^d\sum_{j=1}^dx_ix_jx_i&#39;x_j&#39;\\
&amp;=1+\sum_{i=1}^dx_ix_i&#39;+\sum_{i=1}^dx_ix_i&#39;\sum_{j=1}^dx_jx_j&#39;\\
&amp;=1+\mathbf{x}^T\mathbf{x}&#39;+(\mathbf{x}^T\mathbf{x}&#39;)^2
\end{aligned}
\]</span> 只需要<span class="math inline">\(O(d)\)</span>的复杂度，而<span class="math inline">\(\tilde{d}=O(d^2)\)</span>。</p>
<p>kernel就是变换+内积。</p>
<p>kernel function：<span class="math inline">\(K_\Phi(\mathbf{x},\mathbf{x}&#39;)\triangleq \Phi(\mathbf{x})^T\Phi(\mathbf{x}&#39;)\)</span></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/07/Hoeffding%E4%B8%8D%E7%AD%89%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="demolpc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="demolpc的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/07/Hoeffding%E4%B8%8D%E7%AD%89%E5%BC%8F/" class="post-title-link" itemprop="url">Hoeffding不等式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-07 16:25:38" itemprop="dateCreated datePublished" datetime="2019-09-07T16:25:38+08:00">2019-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-08 10:28:05" itemprop="dateModified" datetime="2019-09-08T10:28:05+08:00">2019-09-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">概率统计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Markov不等式</strong>：随机变量<span class="math inline">\(Z\geq 0\)</span>。对于所有<span class="math inline">\(t\geq 0\)</span>，有 <span class="math display">\[
P(Z\geq t)\leq \frac{E[Z]}{t}
\]</span> 证明：</p>
<p><span class="math inline">\(Z\)</span>的最小最大值分别用<span class="math inline">\(a,b\)</span>表示 <span class="math display">\[
\begin{aligned}
P(Z\geq t)&amp;=\int_t^bp(z)dz\\
&amp;\leq \int_a^t\frac{z}{t}p(z)dz+\int_t^b\frac{z}{t}p(z)dz\\
&amp;=\frac{1}{t}\int_a^bzp(z)dz\\
&amp;=\frac{E[Z]}{t}
\end{aligned}
\]</span></p>
<p><strong>Chebyshev不等式</strong>：随机变量<span class="math inline">\(Z\)</span>均值为<span class="math inline">\(\mu\)</span>，方差为<span class="math inline">\(\sigma^2\)</span>（有限），对于<span class="math inline">\(t\geq0\)</span>，有 <span class="math display">\[
P(|Z-\mu|\geq t)\leq \frac{\sigma^2}{t^2}
\]</span> 证明： <span class="math display">\[
P(|Z-\mu|\geq t)=P((Z-\mu)^2\geq t^2)
\]</span> 然后应用Markov不等式。</p>
<p>令<span class="math inline">\(t=k\sigma\)</span>，得另一种常见形式： <span class="math display">\[
P(|Z-\mu|\geq k\sigma)\leq \frac{1}{k^2}
\]</span></p>
<p>我们想要更强的bound。</p>
<p>定义随机变量<span class="math inline">\(Z\)</span>的moment-generating function： <span class="math display">\[
M_Z(s)\triangleq E[e^{sZ}]
\]</span> <strong>Chernoff bound</strong>：对于任意<span class="math inline">\(t&gt;0\)</span>， <span class="math display">\[
P(Z\geq t)\leq \min_{s&gt;0}e^{-st}M_Z(s)
\]</span> 证明：</p>
<p>对任意<span class="math inline">\(s&gt;0\)</span>， <span class="math display">\[
\begin{aligned}
P(Z\geq t)&amp;=P(sZ\geq st)\\
&amp;=P(e^{sZ}\geq e^{st})\\
&amp;\leq e^{-st}E[e^{sZ}]\quad\text{Markov不等式}\\
&amp;=e^{-st}M_Z(s)
\end{aligned}
\]</span> 因为对任意<span class="math inline">\(s&gt;0\)</span>成立，自然小于最小的。</p>
<p><strong>Hoeffding‘s lemma</strong>：随机变量<span class="math inline">\(X\)</span>满足<span class="math inline">\(E[X]=0\)</span>，且<span class="math inline">\(a\leq X\leq b\)</span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，那么对于任意<span class="math inline">\(s\)</span>，有 <span class="math display">\[
E[e^{sX}]\leq \exp\left(\frac{s^2(b-a)^2}{8}\right)
\]</span> <a href="%5Bhttps://en.wikipedia.org/wiki/Hoeffding%27s_lemma%5D(https://en.wikipedia.org/wiki/Hoeffding&#39;s_lemma)">证明</a></p>
<p><strong>Hoeffding不等式</strong>：<span class="math inline">\(X_1,\dots,X_n\)</span>为独立随机变量，满足<span class="math inline">\(a_i\leq X_i\leq b_i\)</span>。定义<span class="math inline">\(S_n=\sum_{i=1}^n X_i\)</span>，那么对于<span class="math inline">\(t&gt;0\)</span>，有 <span class="math display">\[
P(S_n-E[S_n]\geq t)\leq e^{\frac{-2t^2}{\sum(b_i-a_i)^2}}\\
P(S_n-E[S_n]\leq -t)\leq e^{\frac{-2t^2}{\sum(b_i-a_i)^2}}
\]</span> 证明：</p>
<p>由Chernoff bound得 <span class="math display">\[
\begin{aligned}
P(S_n-E[S_n]\geq t)\leq\min_{s&gt;0}e^{-st}E\left[e^{s(S_n-E[S_n])}\right]
\end{aligned}
\]</span> 并且 <span class="math display">\[
\begin{aligned}
E\left[e^{s(S_n-E[S_n])}\right]&amp;=\Pi_{i=1}^nE\left[e^{s(X_i-E[X_i])}\right]\quad \text{由于$X_i$相互独立}\\
&amp;\leq\Pi_{i=1}^n \exp\left(\frac{s^2(b_i-a_i)^2}{8}\right)\quad\text{由Hoeffding&#39;s lemma}
\end{aligned}
\]</span> 然后只要求得 <span class="math display">\[
\text{argmin}_{s&gt;0}-st+\frac{s^2}{8}\sum_{i=1}^n(b_i-a_i)^2
\]</span> 代入就可得证。</p>
<p>由第一个公式及<span class="math inline">\(Z_i=-X_i\in[-b_i,-a_i]\)</span>就得第二个公式。两个式子组合起来得到： <span class="math display">\[
P(|S_n-E[S_n]|\geq t)\leq 2e^{\frac{-2t^2}{\sum(b_i-a_i)^2}}
\]</span> 如果<span class="math inline">\(X_i\)</span>服从伯努利分布<span class="math inline">\(\text{Ber}(p)\)</span>，那么<span class="math inline">\(a_i=0,b_i=1\)</span>，<span class="math inline">\(S_n\)</span>服从二项分布<span class="math inline">\(\text{ binom}(n,p)\)</span>，<span class="math inline">\(E[s_n]=np\)</span>。 <span class="math display">\[
P(|S_n-np|&gt;t)=p\left(\left|\frac{S_n}{n}-p\right|&gt;\frac{t}{n}\right)\leq 2e^{\frac{-2t^2}{n}}
\]</span> 令<span class="math inline">\(\frac{t}{n}=\epsilon\)</span>，得： <span class="math display">\[
p\left(\left|\frac{1}{n}\sum_{i=1}^nX_i-p\right|&gt;\epsilon\right)\leq 2e^{-2n\epsilon^2}
\]</span></p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>由<span class="math inline">\(E[X]=0\)</span>可得<span class="math inline">\(a\leq 0\leq b\)</span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/31/%E6%84%9F%E7%9F%A5%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="demolpc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="demolpc的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/31/%E6%84%9F%E7%9F%A5%E6%9C%BA/" class="post-title-link" itemprop="url">感知机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-31 11:28:50" itemprop="dateCreated datePublished" datetime="2019-08-31T11:28:50+08:00">2019-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-21 11:53:58" itemprop="dateModified" datetime="2019-09-21T11:53:58+08:00">2019-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>正类用+1表示，负类用-1表示，希望学得 <span class="math display">\[
f(\mathbf{x})=\text{sign}(\mathbf{w}\cdot\mathbf{x}+b)
\]</span> <span class="math inline">\(\mathbf{w}\cdot\mathbf{x}+b=0\)</span>是一个超平面，希望它能完全分隔正类/负类。这里假设这是可以做到的，称为线性可分。</p>
<h1 id="损失函数">损失函数</h1>
<p>任一点<span class="math inline">\(\mathbf{x}_0\)</span>到超平面的距离为： <span class="math display">\[
\frac{|\mathbf{w}\cdot\mathbf{x}_0+b|}{\|\mathbf{w}\|}
\]</span> 对于误分类的数据<span class="math inline">\((\mathbf{x}_i,y_i)\)</span>来说， <span class="math display">\[
-y_i(\mathbf{w}\cdot\mathbf{x}_i+b)&gt;0
\]</span> 因此，误分类点<span class="math inline">\(\mathbf{x}_i\)</span>到超平面的距离为 <span class="math display">\[
\frac{-y_i(\mathbf{w}\cdot\mathbf{x}_i+b)}{\|\mathbf{w}\|}
\]</span> 假设误分类点的集合为<span class="math inline">\(M\)</span>，那么总距离为 <span class="math display">\[
-\frac{1}{\|\mathbf{w}\|}\sum_{\mathbf{x}_i\in M}y_i(\mathbf{w}\cdot\mathbf{x}_i+b)
\]</span> 不考虑<span class="math inline">\(\frac{1}{\|\mathbf{w}\|}\)</span>，就得到损失函数： <span class="math display">\[
L(\mathbf{w},b)=-\sum_{\mathbf{x}_i\in M}y_i(\mathbf{w}\cdot\mathbf{x}_i+b)
\]</span> 令<span class="math inline">\(x_0=1,w_0=b\)</span>，可以写成： <span class="math display">\[
-\sum_{\mathbf{x}_i\in M}y_i\mathbf{w}\cdot\mathbf{x}_i
\]</span></p>
<h1 id="求解">求解</h1>
<p>接下来用随机梯度下降求解，即每次只选取一个误分类点使用梯度下降。假设选取的误分类点为<span class="math inline">\((\mathbf{x}_i,y_i)\)</span>， <span class="math display">\[
\mathbf{w}\leftarrow\mathbf{w}+\eta y_i\mathbf{x}_i
\]</span> 其中<span class="math inline">\(\eta\)</span>为步长（学习率）。</p>
<p>更新之后 <span class="math display">\[
\begin{aligned}
y_i(\mathbf{w}+\eta y_i\mathbf{x}_i)\cdot \mathbf{x}_i&amp;=y_i\mathbf{w}\cdot \mathbf{x}_i+\eta\mathbf{x}_i\cdot \mathbf{x}_i\\
&amp;\geq y_i\mathbf{w}\cdot \mathbf{x}_i
\end{aligned}
\]</span></p>
<p>所以更新后更接近正确分类（<span class="math inline">\(y_i\mathbf{w}\cdot \mathbf{x}_i&gt;0\)</span>）。</p>
<h1 id="算法收敛性">算法收敛性</h1>
<p>从上面的过程可以看出，在纠正一个误分类点时，可能会使原来正确分类的点被误分类。如何证明算法收敛？</p>
<p>因为线性可分，存在<span class="math inline">\(\|\mathbf{w}_f\|=1\)</span>，使得 <span class="math display">\[
\forall i\quad y_i\mathbf{w}_f\cdot\mathbf{x}_i\geq\min_n y_n\mathbf{w}_f\cdot\mathbf{x}_n\triangleq\gamma&gt;0
\]</span> <span class="math inline">\(\mathbf{w}_k\)</span>表示第<span class="math inline">\(k\)</span>轮更新后的参数，<span class="math inline">\(\mathbf{w}_0\)</span>设为全0向量。</p>
<p>假设<span class="math inline">\((\mathbf{x}_i,y_i)\)</span>是第<span class="math inline">\(k\)</span>轮更新中被选中的误分类点 <span class="math display">\[
\begin{aligned}
\mathbf{w}_f\cdot\mathbf{w}_{k}&amp;=\mathbf{w}_f\cdot(\mathbf{w}_{k-1}+\eta y_i\mathbf{x}_i)\\
&amp;\geq \mathbf{w}_f\cdot\mathbf{w}_{k-1}+\eta\gamma\\
&amp;\geq\dots\\
&amp;\geq k\eta\gamma
\end{aligned}
\]</span> 还要看<span class="math inline">\(\|\mathbf{w}_k\|\)</span>的增长速度， <span class="math display">\[
\begin{aligned}
\|\mathbf{w}_k\|^2&amp;=\|\mathbf{w}_{k-1}\|^2+2\eta y_i\mathbf{w}_{k-1}\cdot\mathbf{x}_{i}+\eta^2\|\mathbf{x}_i\|^2\\
&amp;\leq\|\mathbf{w}_{k-1}\|^2+\eta^2\|\mathbf{x}_i\|^2\quad(由误分类条件)\\
&amp;\leq\|\mathbf{w}_{k-1}\|^2+\eta^2R^2\quad(R^2\triangleq\max_i\|\mathbf{x}_i\|^2)\\
&amp;\leq\dots\\
&amp;\leq k\eta^2R^2
\end{aligned}
\]</span> 那么由 <span class="math display">\[
\frac{k\eta\gamma}{\sqrt{k}\eta R}\leq\mathbf{w}_f\cdot\frac{\mathbf{w}_k}{\|\mathbf{w}_k\|}\leq 1
\]</span> 得 <span class="math display">\[
k\leq \left(\frac{R}{\gamma}\right)^2
\]</span> 即迭代次数有上限，算法会收敛。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/25/%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="demolpc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="demolpc的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/25/%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">坐标系转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-25 10:07:52" itemprop="dateCreated datePublished" datetime="2019-08-25T10:07:52+08:00">2019-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-10 22:50:20" itemprop="dateModified" datetime="2019-09-10T22:50:20+08:00">2019-09-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="方向余弦矩阵dcm">方向余弦矩阵（DCM）</h1>
<p><span class="math inline">\(\mathbf{r}_A,\mathbf{r}_B\)</span>分别为向量<span class="math inline">\(\mathbf{r}\)</span>在坐标系<span class="math inline">\(A，B\)</span>中的坐标，由 <span class="math display">\[
\mathbf{r}= \begin{pmatrix}\mathbf{i}_B &amp; \mathbf{j}_B &amp; \mathbf{k}_B
\end{pmatrix}\mathbf{r}_B=\begin{pmatrix}\mathbf{i}_A &amp; \mathbf{j}_A &amp; \mathbf{k}_A
\end{pmatrix}\mathbf{r}_A
\]</span></p>
<p>得： <span class="math display">\[
\begin{aligned}
\mathbf{r}_B&amp;=\begin{pmatrix}\mathbf{i}_B^\intercal\\
\mathbf{j}_B^\intercal\\
\mathbf{k}_B^\intercal
\end{pmatrix}\begin{pmatrix}\mathbf{i}_A &amp; \mathbf{j}_A &amp; \mathbf{k}_A
\end{pmatrix}\mathbf{r}_A\\
&amp;\triangleq R_{BA}\mathbf{r}_A
\end{aligned}
\]</span> <span class="math inline">\(R_{BA}\)</span>表示从<span class="math inline">\(A\)</span>到<span class="math inline">\(B\)</span>的坐标转换矩阵。</p>
<p>由<span class="math inline">\(R_{BA}\)</span>的定义还可得基变换： <span class="math display">\[
\begin{pmatrix}\mathbf{i}_A &amp; \mathbf{j}_A &amp; \mathbf{k}_A
\end{pmatrix}=\begin{pmatrix}\mathbf{i}_B &amp; \mathbf{j}_B &amp; \mathbf{k}_B
\end{pmatrix}R_{BA}
\]</span></p>
<h1 id="欧拉角">欧拉角</h1>
<p>intrinsic rotation是指绕当前坐标系（而不是某个固定坐标系）的轴转动。</p>
<p><span class="math inline">\(A\)</span>绕某轴逆时针旋转<span class="math inline">\(\theta\)</span>，得到<span class="math inline">\(B\)</span>。对于<span class="math inline">\(R_{BA}\)</span>，根据定义得出如下结果<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>：</p>
<p>绕<span class="math inline">\(X\)</span>轴旋转 <span class="math display">\[
R_x=
\begin{bmatrix}
  1 &amp; 0 &amp; 0 \\
   0 &amp; c_\theta &amp; s_\theta \\  
    0 &amp; -s_\theta &amp; c_\theta 
\end{bmatrix}
\]</span> 绕<span class="math inline">\(Y\)</span>轴旋转 <span class="math display">\[
R_y=
\begin{bmatrix} 
    c_\theta &amp; 0 &amp; -s_\theta \\  
    0 &amp; 1 &amp; 0\\
    s_\theta &amp; 0 &amp; c_\theta  
\end{bmatrix}
\]</span> 绕<span class="math inline">\(Z\)</span>轴旋转 <span class="math display">\[
R_z=
\begin{bmatrix} 
    c_\theta &amp; s_\theta &amp; 0\\  
    -s_\theta &amp; c_\theta &amp; 0\\  
    0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span> 如果按<span class="math inline">\(Z\rightarrow Y\rightarrow X\)</span>的顺序转动， <span class="math display">\[
R_{BA}=R_xR_yR_z=\begin{bmatrix}       
    c_yc_z &amp; c_ys_z &amp; -s_y \\
    s_xs_yc_z-c_xs_z &amp; s_xs_ys_z+c_xc_z &amp; s_xc_y \\
    c_xs_yc_z+s_xs_z &amp; c_xs_ys_z-s_xc_z &amp; c_xc_y
\end{bmatrix}
\]</span> 可得欧拉角和DCM的转换关系： <span class="math display">\[
\text{tan}(\theta_z)=\frac {R_{12}} {R_{11}}\\
\text{sin}(\theta_y)=-R_{13}\\
\text{tan}(\theta_x)=\frac {R_{23}} {R_{33}}
\]</span> 若是小角度转动， <span class="math display">\[
\begin{equation}
R=\begin{bmatrix}
1  &amp; \theta_z &amp; -\theta_y\\
-\theta_z &amp; 1 &amp; \theta_x\\
\theta_y &amp; -\theta_x &amp; 1
\end{bmatrix}=I-[\theta]_\times
\end{equation}
\]</span> 可见小角度转动与转动顺序无关（即只与绕XYZ各轴转过的角度有关。如果只有俩轴，比如Z-&gt;X-&gt;Z，那么未出现的轴角度为0，出现两次的轴的角度相加）。</p>
<h2 id="extrinsic-rotation">Extrinsic rotation</h2>
<p>设固定坐标系为<span class="math inline">\(A\)</span>。坐标系<span class="math inline">\(B\)</span>绕<span class="math inline">\(A\)</span>的<span class="math inline">\(\mathbf{u}\)</span>轴转动角度<span class="math inline">\(\phi\)</span>，这个转动用<span class="math inline">\(R_{\phi \mathbf{u}}\)</span>表示，得坐标系<span class="math inline">\(C\)</span>。求<span class="math inline">\(R_{CA}\)</span>。</p>
<p>首先 <span class="math display">\[
R_{CA}=R_{BD}
\]</span> 其中<span class="math inline">\(D\)</span>为<span class="math inline">\(A\)</span>绕<span class="math inline">\(\mathbf{u}\)</span>轴转动角度<span class="math inline">\(-\phi\)</span>得到。这个结论对于二维转动很直观，对于三维其实也容易看出。按定义，只要证明两对坐标系的基的内积相等即可。把基分解到平行于转轴和垂直于转轴。平行部分的内积显然不变，垂直部分由二维情况可知也不变，且平行于垂直部分内积为0。因此得证。 <span class="math display">\[
R_{BD}=R_{BA}R_{AD}=R_{BA}R_{DA}^{-1}=R_{BA}R_{-\phi \mathbf{u}}^{-1}=R_{BA}R_{\phi \mathbf{u}}
\]</span> 因此得到结论，绕固定坐标系的轴转动，<span class="math inline">\(R\)</span>是乘在右边的。</p>
<h1 id="四元数">四元数</h1>
<p><span class="math display">\[
\mathbf{x}_G=\mathbf{q}_{GL}\otimes \mathbf{x}_L\otimes\mathbf{q}^*_{GL}
\]</span></p>
<p>其中G表示global，或者n系；L表示local，或者b系。</p>
<p>这样定义是为了和旋转三维向量的公式形式保持一致。</p>
<h1 id="运动方程">运动方程</h1>
<h2 id="四元数-1">四元数</h2>
<p>如果是在L系中表达扰动（即上述的intrinsic rotation）， <span class="math display">\[
q(t+\Delta t)=q(t)\otimes\Delta q_L=q(t)\otimes\text{Exp}(\Delta\phi_L)
\]</span> <span class="math display">\[
\begin{aligned}
\dot{q}&amp;\triangleq \lim_{\Delta t\to 0}\frac{q(t+\Delta t)-q(t)}{\Delta t}\\
&amp;=\lim_{\Delta t\to 0}\frac{q\otimes\Delta q_L-q}{\Delta t}\\
&amp;=\lim_{\Delta t\to 0}\frac{q\otimes\left(\begin{bmatrix}1\\\Delta\phi_L/2\end{bmatrix}-\begin{bmatrix}1\\0\end{bmatrix}\right)}{\Delta t}\\
&amp;=\lim_{\Delta t\to 0}\frac{q\otimes\begin{bmatrix}0\\\Delta\phi_L/2\end{bmatrix}}{\Delta t}\\
&amp;=\frac{1}{2}q\otimes \omega_L
\end{aligned}
\]</span></p>
<p>其中<span class="math inline">\(\text{Exp}(\Delta\phi_L)\)</span>用了小角度近似。</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><span class="math inline">\(s_\theta\)</span>放置位置记忆方法：放在转动轴的上一列（循环）。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/17/%E5%9B%9B%E5%85%83%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="demolpc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="demolpc的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/17/%E5%9B%9B%E5%85%83%E6%95%B0/" class="post-title-link" itemprop="url">四元数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-17 10:18:48" itemprop="dateCreated datePublished" datetime="2019-08-17T10:18:48+08:00">2019-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-22 10:30:49" itemprop="dateModified" datetime="2019-09-22T10:30:49+08:00">2019-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="定义">定义</h1>
<p><span class="math display">\[
Q = a+bi+cj+dk
\]</span> 其中<span class="math inline">\({i,j,k}\)</span>是虚数单元，满足： <span class="math display">\[
i^2=j^2=k^2=ijk=-1
\]</span> <span class="math inline">\(Q=a\)</span>称为实四元数，<span class="math inline">\(Q=bi+cj+dk\)</span>称为虚四元数。<br />
实部+虚部的表示方式有时不方便，只要遵循虚部的运算规则，就可以写成标量+向量的形式： <span class="math display">\[
Q=q_w+q_xi+q_yj+q_zk\quad \Leftrightarrow\quad Q=q_w+\mathbf{q}_v
\]</span> 下面将四元数<span class="math inline">\(Q\)</span>写成四维向量<span class="math inline">\(\mathbf{q}\)</span>的形式： <span class="math display">\[
\mathbf{q}\triangleq 
\begin{bmatrix}
q_w\\
\mathbf{q}_v
\end{bmatrix}=
\begin{bmatrix}
q_w\\
q_x\\
q_y\\
q_z
\end{bmatrix}
\]</span> 这样就可以用矩阵来进行有关四元数的运算。</p>
<h1 id="主要性质">主要性质</h1>
<h2 id="乘法">乘法</h2>
<p>四元数的乘法只要按定义来进行就行了，用标量和向量的形式来表示是比较方便的： <span class="math display">\[
\mathbf{p}\otimes\mathbf{q}=
\begin{bmatrix}
p_wq_w-\mathbf{p}_v^\top\mathbf{q}_v\\
p_w\mathbf{q}_v+q_w\mathbf{p}_v+\mathbf{p}_v\times\mathbf{q}_v
\end{bmatrix}
\]</span> 由于结果的向量部分有个叉积，而叉积不满足交换律，因此四元数乘法一般也不满足交换律，即： <span class="math display">\[
\mathbf{p}\otimes\mathbf{q}\neq\mathbf{q}\otimes\mathbf{p}
\]</span> 但是乘法满足结合律（暴力验证）： <span class="math display">\[
(\mathbf{p}\otimes\mathbf{q})\otimes\mathbf{r}=\mathbf{p}\otimes(\mathbf{q}\otimes\mathbf{r})
\]</span> 四元数乘法可以写成矩阵乘法的形式： <span class="math display">\[
\mathbf{q_1}\otimes\mathbf{q_2}=[\mathbf{q_1}]_L\mathbf{q_2}\\
\mathbf{q_1}\otimes\mathbf{q_2}=[\mathbf{q_2}]_R\mathbf{q_1}
\]</span> 其中 <span class="math display">\[
[\mathbf{q}]_L=q_w\mathbf{I}+
\begin{bmatrix}
0 &amp; -\mathbf{q}_v^\top\\
\mathbf{q}_v &amp; [\mathbf{q}_v]_{\times}
\end{bmatrix}
\]</span> <span class="math display">\[
[\mathbf{q}]_R=q_w\mathbf{I}+
\begin{bmatrix}
0 &amp; -\mathbf{q}_v^\top\\
\mathbf{q}_v &amp; -[\mathbf{q}_v]_{\times}
\end{bmatrix}
\]</span> 这里用到了反对称矩阵： <span class="math display">\[
[\mathbf{a}]_{\times}\triangleq 
\begin{bmatrix}
0 &amp; -a_z &amp; a_y\\
a_z &amp; 0 &amp; -a_x\\
-a_y &amp; a_x &amp;  0
\end{bmatrix}
\]</span> 这个矩阵和叉积有关： <span class="math display">\[
[\mathbf{a}]_{\times}\mathbf{b}=\mathbf{a}\times\mathbf{b}
\]</span> <span class="math display">\[
[\mathbf{q}]_L[\mathbf{q}]_L^T=[\mathbf{q}]_R[\mathbf{q}]_R^T=\|\mathbf{q}\|^2I
\]</span> 即如果<span class="math inline">\(\mathbf{q}\)</span>是单位四元数，那么这两个矩阵是正交矩阵。</p>
<p>由于 <span class="math display">\[
\begin{aligned}
\mathbf{q}\otimes\mathbf{x}\otimes\mathbf{p}&amp;=(\mathbf{q}\otimes\mathbf{x})\otimes\mathbf{p}=[\mathbf{p}]_R[\mathbf{q}]_L\mathbf{x}\\
&amp;=\mathbf{q}\otimes(\mathbf{x}\otimes\mathbf{p})=[\mathbf{q}]_L[\mathbf{p}]_R\mathbf{x}
\end{aligned}
\]</span></p>
<p>可见L,R矩阵满足交换律： <span class="math display">\[
[\mathbf{p}]_R[\mathbf{q}]_L=[\mathbf{q}]_L[\mathbf{p}]_R
\]</span></p>
<h2 id="identity">identity</h2>
<p>幺元<span class="math inline">\(\mathbf{q_1}\)</span>满足： <span class="math display">\[
\mathbf{q_1}\otimes\mathbf{q}=\mathbf{q}\otimes\mathbf{q_1}=\mathbf{q}
\]</span> 它就是实数1： <span class="math display">\[
\mathbf{q_1}=1=
\begin{bmatrix}
1\\
\mathbf{0}_v
\end{bmatrix}
\]</span></p>
<h2 id="共轭">共轭</h2>
<p>和复数类似，共轭定义为： <span class="math display">\[
\mathbf{q}^*\triangleq q_w-\mathbf{q}_v=
\begin{bmatrix}
q_w\\
-\mathbf{q}_v
\end{bmatrix}
\]</span> 满足： <span class="math display">\[
\mathbf{q}\otimes\mathbf{q}^*=\mathbf{q}^*\otimes\mathbf{q}=q_w^2+q_x^2+q_y^2+q_z^2
\]</span> <span class="math display">\[
(\mathbf{p}\otimes\mathbf{q})^*=\mathbf{q}^*\otimes\mathbf{p}^*
\]</span></p>
<h2 id="norm">norm</h2>
<p>范数定义为： <span class="math display">\[
\|\mathbf{q}\| \triangleq \sqrt{\mathbf{q}\otimes\mathbf{q}^*}=\sqrt{q_w^2+q_x^2+q_y^2+q_z^2}
\]</span> 满足： <span class="math display">\[
\|\mathbf{p}\otimes\mathbf{q}\|=\|\mathbf{p}\|\|\mathbf{q}\|
\]</span></p>
<h2 id="逆">逆</h2>
<p>逆定义为： <span class="math display">\[
\mathbf{q}\otimes\mathbf{q}^{-1}=\mathbf{q}^{-1}\otimes\mathbf{q}=\mathbf{q}_1
\]</span> 显然， <span class="math display">\[
\mathbf{q}^{-1}=\frac{\mathbf{q}^*}{\|\mathbf{q}\|^2}
\]</span></p>
<h2 id="单位四元数">单位四元数</h2>
<p>或者叫归一化的四元数定义为<span class="math inline">\(\|\mathbf{q}\|=1\)</span>，因此 <span class="math display">\[
\mathbf{q}^{-1}=\mathbf{q}^*
\]</span> 单位四元数可以写成： <span class="math display">\[
\mathbf{q}=
\begin{bmatrix}
\cos\theta\\
\mathbf{u}\sin\theta
\end{bmatrix}
\]</span> 其中<span class="math inline">\(\|\mathbf{u}\|=1\)</span>。</p>
<h1 id="附加性质">附加性质</h1>
<h2 id="虚四元数的乘法">虚四元数的乘法</h2>
<p><span class="math display">\[
\mathbf{q}_v\otimes\mathbf{q}_v=-\mathbf{q}_v^\top\mathbf{q}_v=-\|\mathbf{q}_v\|^2
\]</span> 对于单位虚四元数<span class="math inline">\(\|\mathbf{u}\|=1\)</span>，因此： <span class="math display">\[
\mathbf{u}\otimes \mathbf{u}=-1
\]</span> 与虚数<span class="math inline">\(i\cdot i=-1\)</span>类似。</p>
<h2 id="虚四元数的指数函数">虚四元数的指数函数</h2>
<p>与实数类似，根据级数展开来定义： <span class="math display">\[
e^{\mathbf{q}}\triangleq \sum_{0}^{\infty}\frac{1}{k!}\mathbf{q}^k
\]</span> 对于虚四元数<span class="math inline">\(\mathbf{v}=\mathbf{u}\theta\)</span>，其中<span class="math inline">\(\|\mathbf{u}\|=1\)</span>，有： <span class="math display">\[
e^{\mathbf{v}}=e^{\mathbf{u}\theta}=\cos\theta+\mathbf{u}\sin\theta=
\begin{bmatrix}
\cos\theta\\
\mathbf{u}\sin\theta
\end{bmatrix}
\]</span> 是虚数的欧拉公式的扩展。 注意<span class="math inline">\(\|e^{\mathbf{v}}\|=1\)</span>，因此虚四元数的指数函数为单位四元数。</p>
<h2 id="一般四元数的指数函数">一般四元数的指数函数</h2>
<p>由于当其中一个四元数为实数时，四元数乘法满足交换律，因此： <span class="math display">\[
e^{\mathbf{q}}=e^{q_w+\mathbf{q}_v}=e^{q_w}e^{\mathbf{q}_v}
\]</span></p>
<h2 id="单位四元数的对数">单位四元数的对数</h2>
<p>四元数的对数用指数来定义，如果<span class="math inline">\(\|\mathbf{q}\|=1\)</span>， <span class="math display">\[
\log \mathbf{q}=\log(\cos\theta+\mathbf{u}\sin\theta)=\log(e^{\mathbf{u}\theta})=\mathbf{u}\theta
\]</span></p>
<h2 id="一般四元数的对数">一般四元数的对数</h2>
<p><span class="math display">\[
\log\mathbf{q}=\log(\|\mathbf{q}\|\frac{\mathbf{q}}{\|\mathbf{q}\|})=\log\|\mathbf{q}\|+\mathbf{u}\theta
\]</span></p>
<h2 id="exponential-forms-of-the-type-mathbfqt">Exponential forms of the type <span class="math inline">\(\mathbf{q}^t\)</span></h2>
<p>对于<span class="math inline">\(t\in \mathbb{R}\)</span>， <span class="math display">\[
\mathbf{q}^t=\exp(\log(\mathbf{q}^t))=\exp(t\log(\mathbf{q}))
\]</span> 如果<span class="math inline">\(\|\mathbf{q}\|=1\)</span>，写成<span class="math inline">\(\mathbf{q}=\begin{bmatrix}\cos\theta, &amp; \mathbf{u}\sin\theta\end{bmatrix}\)</span>，因此<span class="math inline">\(\log(\mathbf{q})=\mathbf{u}\theta\)</span>，那么 <span class="math display">\[
\mathbf{q}^t=\exp(t\mathbf{u}\theta)=
\begin{bmatrix}
\cos t\theta\\
\mathbf{u}\sin t\theta
\end{bmatrix}
\]</span></p>
<h1 id="参考资料">参考资料</h1>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1711.02508.pdf">Quaternion kinematics for the error-state Kalman filter</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/10/%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="demolpc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="demolpc的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/10/%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95/" class="post-title-link" itemprop="url">线性筛法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-10 14:41:57" itemprop="dateCreated datePublished" datetime="2019-08-10T14:41:57+08:00">2019-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-05 12:46:10" itemprop="dateModified" datetime="2019-10-05T12:46:10+08:00">2019-10-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>线性筛法不仅是线性的（每个数只筛一次），还能得到每个数的最小素因子，而有了这，因式分解就很容易了。</p>
<p>对于合数<span class="math inline">\(x\)</span>，令<span class="math inline">\(p_x\)</span>表示<span class="math inline">\(x\)</span>的最小素因子，则 <span class="math display">\[
x=i*p_x
\]</span> 每个合数就是在<span class="math inline">\(i=x/p_x\)</span>的时候筛掉的，也就是尽可能晚的时候。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> minPrimeFactor[N+<span class="number">1</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; primes;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linearSieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (minPrimeFactor[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            minPrimeFactor[i] = i;</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : primes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &gt; minPrimeFactor[i] || i * p &gt; N)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            minPrimeFactor[i*p] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<p><a target="_blank" rel="noopener" href="https://www.hackerrank.com/topics/sieve-of-eratosthenes-linear-time">hackerrank</a></p>
<p>David Gries, Jayadev Misra. A Linear Sieve Algorithm for Finding Prime Numbers [1978]</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/10/Hough%E5%8F%98%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="demolpc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="demolpc的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/10/Hough%E5%8F%98%E6%8D%A2/" class="post-title-link" itemprop="url">Hough变换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-10 10:05:48" itemprop="dateCreated datePublished" datetime="2019-08-10T10:05:48+08:00">2019-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-18 20:12:26" itemprop="dateModified" datetime="2019-08-18T20:12:26+08:00">2019-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" itemprop="url" rel="index"><span itemprop="name">计算机视觉</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="检测直线">检测直线</h1>
<p>给定二值图像中的<span class="math inline">\(n\)</span>个点，要找到图像中的直线。一种方法是枚举所有可能的<span class="math inline">\(n*(n-1)/2\)</span>条直线，然后检测每个点是否足够靠近线。如果足够靠近，就给这条线投一票。最后票数多的直线很可能是真正的直线。这样的复杂度是<span class="math inline">\(n^3\)</span>的，对于一般的图片大小并不实用。</p>
<h2 id="参数空间方法">参数空间方法</h2>
<p>Hough变换的思想最初是Hough在一篇专利中提出的。 考虑<span class="math inline">\(xy\)</span>平面上的一点<span class="math inline">\((x_i,y_i)\)</span>，假设通过这个点的某条直线的斜率为<span class="math inline">\(a\)</span>，截距为<span class="math inline">\(b\)</span>，那么<span class="math inline">\(y_i = ax_i+b\)</span>。将式子写成<span class="math inline">\(b=-x_ia+y_i\)</span>，即通过给定点的直线的斜率和截距满足一定关系。在<span class="math inline">\(ab\)</span>平面（参数空间），这是一条直线。另一个点<span class="math inline">\((x_j,y_j)\)</span>在参数空间也有一条关联的直线。如果这两条直线不平行，那么会交于一点<span class="math inline">\((a&#39;,b&#39;)\)</span>。<span class="math inline">\((a&#39;,b&#39;)\)</span>既是通过<span class="math inline">\((x_i,y_i)\)</span>的某条直线的参数，又是通过<span class="math inline">\((x_j,y_j)\)</span>的某条直线的参数，显然这条直线就是连接<span class="math inline">\((x_i,y_i)\)</span>，<span class="math inline">\((x_j,y_j)\)</span>的直线。 以上的方案有一点缺陷。我们知道只要<span class="math inline">\((x_i,y_i)\)</span>，<span class="math inline">\((x_j,y_j)\)</span>不是同一点，总能唯一确定一条直线。然而参数空间却有可能无法表示对应的参数值。也就是参数空间的两条直线平行的时候，无法求得参数。此时两条直线斜率相同：<span class="math inline">\(-x_i=-x_j\)</span>。也就是当两点的<span class="math inline">\(x\)</span>坐标相同时，连线是一条竖直的线，斜率无穷大，无法在参数空间表示。</p>
<h2 id="法线表示">法线表示</h2>
<p>针对上述问题，我们现在用的Hough变换版本是Hart（和Duda）1972年在《Use of the Hough transformation to detect lines and curves in pictures》这篇论文中提出的。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 它利用的是直线的另一种表示：法线表示。 <span class="math display">\[
x\cos\theta+y\sin\theta = \rho
\]</span> 其中<span class="math inline">\(\theta\)</span>是直线的法线和<span class="math inline">\(x\)</span>轴的夹角，<span class="math inline">\(\rho\)</span>是原点到直线的距离（根据对<span class="math inline">\(\theta\)</span>取值范围的规定，可能为负）。把上式写成向量<span class="math inline">\((x,y)\)</span>与单位法向量<span class="math inline">\((\cos\theta,\sin\theta)\)</span>的点积，就很显然。从几何上容易看出，<span class="math inline">\(\rho\)</span>的最大取值为图像的对角线长度，因此不会有斜率-截距表示法中的无穷大问题。 图像中的一个点关联着<span class="math inline">\(\rho\theta\)</span>参数空间中的一条正弦曲线。一条直线上的点对应的正弦曲线族在<span class="math inline">\(\rho\theta\)</span>空间中会交于同一点。如果每个<span class="math inline">\((\theta,\rho)\)</span>关联着一个累加器，其数值是参数空间中所有正弦曲线通过它的次数，那么某条直线对应的累积器数值就是直线上点的个数。我们无法枚举无限多的<span class="math inline">\((\theta,\rho)\)</span>，Hough变换的做法是将<span class="math inline">\(\rho\theta\)</span>空间按一定的分辨率网格化。对于图像中每个点，按设定的分辨率枚举所有的<span class="math inline">\(\theta\)</span>，按<span class="math inline">\(\rho = x\cos\theta+y\sin\theta\)</span> 得到对应的<span class="math inline">\(\rho\)</span>，根据设定的<span class="math inline">\(\rho\)</span>的分辨率得到对应网格，其累加器加一。最后把数值大的累加器对应的参数认定为直线。</p>
<h2 id="opencv中的实现">opencv中的实现</h2>
<p>opencv中<span class="math inline">\(\theta\)</span>的取值范围为0到180度，那么<span class="math inline">\(\rho\)</span>是有可能为负的。其范围为<span class="math inline">\(-D\leq\rho\leq D\)</span>，其中<span class="math inline">\(D\)</span>为对角线长。 实现在<code>hough.cpp</code>的<code>HoughLinesStandard</code>函数中。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max_rho = width + height;</span><br><span class="line"><span class="keyword">int</span> min_rho = -max_rho;</span><br><span class="line"><span class="keyword">int</span> numrho = <span class="built_in">cvRound</span>(((max_rho - min_rho) + <span class="number">1</span>) / rho);</span><br></pre></td></tr></table></figure> 可以看到它取的<span class="math inline">\(\rho\)</span>的最大值为宽加高，保证了大于对角线长。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stage 1. fill accumulator</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; height; i++ )</span><br><span class="line">    <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; width; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( image[i * step + j] != <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; numangle; n++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> r = <span class="built_in">cvRound</span>( j * tabCos[n] + i * tabSin[n] );</span><br><span class="line">                r += (numrho - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                accum[(n+<span class="number">1</span>) * (numrho+<span class="number">2</span>) + r+<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> <code>int r = cvRound( j * tabCos[n] + i * tabSin[n] );</code>表示<span class="math inline">\(r = \frac{x\cos\theta+y\sin\theta}{\Delta\rho}\)</span>，其中<span class="math inline">\(\Delta \rho\)</span>为<span class="math inline">\(\rho\)</span>的分辨率。这里<span class="math inline">\(r\)</span>取值范围在<span class="math inline">\(-\frac{D}{\Delta \rho}\)</span>和<span class="math inline">\(\frac{D}{\Delta \rho}\)</span>之间，<code>r += (numrho - 1) / 2;</code>是为了把值shift到非负范围才能作为累加器的列索引。（累加器的行索引为<span class="math inline">\(\theta\)</span>，列索引为<span class="math inline">\(\rho\)</span>）。 下面的代码则是相应地还原回真正的<span class="math inline">\(\rho\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="built_in">cvFloor</span>(idx*scale) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> r = idx - (n+<span class="number">1</span>)*(numrho+<span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">line.rho = (r - (numrho - <span class="number">1</span>)*<span class="number">0.5f</span>) * rho;</span><br></pre></td></tr></table></figure>
<h3 id="其他实现细节">其他实现细节</h3>
<ol type="1">
<li>在累加器矩阵中只会保留局部极大值，也就是比上下左右的累积器的值都要大才有可能输出，这样可以去掉非常接近的线。</li>
<li>结果是按累加器的值从大到小排序的。</li>
</ol>
<h3 id="指定theta范围">指定<span class="math inline">\(\theta\)</span>范围</h3>
<p>在做跟踪的时候，可能只需要某个范围的<span class="math inline">\(\theta\)</span>中做检测。<code>Houghlines</code>中可以指定最小和最大的<span class="math inline">\(\theta\)</span>。如果是以两个点表示的直线，先要得到<span class="math inline">\(\theta\)</span>值。由 <span class="math display">\[
x_1\cos(\theta)+y_1\sin(\theta) = x_2\cos(\theta)+y_2\sin(\theta) = \rho
\]</span> 得： <span class="math display">\[
\tan\theta = \frac{x_1-x_2}{y_2-y_1}
\]</span> 又因为在opencv中<span class="math inline">\(\theta\in [0,\pi]\)</span>，因此 <span class="math display">\[
\theta =
        \begin{cases}
        \arctan(\frac{x_1-x_2}{y_2-y_1}) ,  &amp; \text{if $\arctan(\frac{x_1-x_2}{y_2-y_1})\geq 0$ } \\
        \pi - \arctan(\frac{x_1-x_2}{y_2-y_1}), &amp; \text{else}
        \end{cases}
\]</span> 直线和<span class="math inline">\(\theta\)</span>对应关系如下图，可见在竖直线时<span class="math inline">\(\theta\)</span>不连续变化。 <img src="/images/hough-theta.png" alt="对应关系" /></p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>有兴趣的可以看Hart写的《How the Hough transform was invented》了解这段历史<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/10/Iterative%20Closest%20Point/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="demolpc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="demolpc的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/10/Iterative%20Closest%20Point/" class="post-title-link" itemprop="url">Iterative Closest Point</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-10 09:56:10" itemprop="dateCreated datePublished" datetime="2019-08-10T09:56:10+08:00">2019-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-26 22:02:03" itemprop="dateModified" datetime="2019-08-26T22:02:03+08:00">2019-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题">问题</h1>
<p>要把三维空间中的点集<span class="math inline">\(\{p_1,p_2,\cdots,p_n\}\)</span>通过旋转、平移和点集<span class="math inline">\(\{q_1,q_2,\cdots,q_n\}\)</span>匹配起来。<span class="math inline">\(p\)</span>可能是预先给定的模型，而<span class="math inline">\(q\)</span>是在另一个坐标系中观察的结果，匹配就是要找到两个坐标系的转换关系。</p>
<h1 id="给定对应关系的情况">给定对应关系的情况</h1>
<p>先考虑简单的情形，即给定了两个集合中点的对应关系，<span class="math inline">\(p_i\)</span>对应<span class="math inline">\(q_i\)</span>。 定义两个点集间的距离为： <span class="math display">\[
\sum_{i=1}^n\|p_i-q_i\|^2
\]</span> 我们的目标是找到旋转矩阵<span class="math inline">\(R\)</span>、平移向量<span class="math inline">\(b\)</span>，使得<span class="math inline">\(p\)</span>变换后与<span class="math inline">\(q\)</span>的距离最小 <span class="math display">\[
\min_{R,b}\sum_{i=1}^n\|Rp_i+b-q_i\|^2
\]</span> 目标函数对<span class="math inline">\(b\)</span>求导并令导数为<span class="math inline">\(\mathbf{0}\)</span>，得： <span class="math display">\[
b=\bar{q}-R\bar{p}
\]</span> 其中 <span class="math display">\[
\bar{p}=\frac{1}{n}\sum_{i=1}^np_i\\
\bar{q}=\frac{1}{n}\sum_{i=1}^nq_i\\
\]</span> 分别是点集的“质心”。 将<span class="math inline">\(b\)</span>的表达式代入目标函数，得到： <span class="math display">\[
\sum_{i=1}^n\|Rp_i+b-q_i\|=\sum_{i=1}^n\|Rp_i&#39;-q_i&#39;\|^2
\]</span> 其中： <span class="math display">\[
p_i&#39;=p_i-\bar{p}\\
q_i&#39;=q_i-\bar{q}
\]</span> 为点相对于质心的坐标。 <span class="math display">\[
\begin{aligned}
\sum_{i=1}^n\|Rp_i&#39;-q_i&#39;\|^2&amp;=\sum_{i=1}^n(Rp_i&#39;\cdot Rp_i&#39;)-2\sum_{i=1}^n(Rp_i&#39;\cdot q_i&#39;)+\sum_{i=1}^n(q_i&#39;\cdot q_i&#39;)\\
&amp;=\sum_{i=1}^n(\|p_i&#39;\|^2+\|q_i&#39;\|^2)-2\sum_{i=1}^nRp_i&#39;\cdot q_i&#39;
\end{aligned}
\]</span> 上式中<span class="math inline">\(Rp_i&#39;\cdot Rp_i&#39;=\|p_i&#39;\|^2\)</span>是因为旋转不改变向量长度。 上式第一项与<span class="math inline">\(R\)</span>无关，因此只要最小化第二项。或者等价地求如下最大化： <span class="math display">\[
\max_R\sum_{i=1}^nRp_i&#39;\cdot q_i&#39;
\]</span> 下面用两种方法来求解。 采用新符号<span class="math inline">\(x_i=p_i&#39;\)</span>，<span class="math inline">\(y_i=q_i&#39;\)</span></p>
<h2 id="svd">SVD</h2>
<p>用SVD推导时似乎常引用资料[4]，不过我下面采用资料[3]中的推导，因为更简单直接。 <span class="math display">\[
\begin{aligned}
\sum_{i=1}^nRx_i\cdot y_i&amp;=\sum_{i=1}^ny_i^TRx_i\\
&amp;=tr(\sum_{i=1}^ny_i^TRx_i) \quad\text{标量=标量的迹}\\
&amp;=tr(\sum_{i=1}^nx_iy_i^TR) \quad\text{因为tr(AB)=tr(BA)}\\
&amp;=tr(CR) \quad C\triangleq\sum_{i=1}^nx_iy_i^T\\
&amp;=tr(U\Lambda V^TR) \quad\text{SVD分解：$C=U\Lambda V^T$}\\
&amp;=tr(\Lambda V^TRU) \\
&amp;=tr(\Lambda T) \quad T\triangleq V^TRU\\
&amp;=\sum_{i=1}^3\lambda_iT_{ii}
\end{aligned}
\]</span> 由于<span class="math inline">\(V,R,U\)</span>都是正交矩阵，因此<span class="math inline">\(T\)</span>是正交矩阵，即每一列的长度为1，则<span class="math inline">\(T_{ii}\leq 1\)</span>，因此： <span class="math display">\[
\sum_{i=1}^3\lambda_iT_{ii}\leq\sum_{i=1}^3\lambda_i
\]</span> 当<span class="math inline">\(T_{ii}=1\)</span>时等号成立，此时<span class="math inline">\(T\)</span>的其他元素为0，即<span class="math inline">\(T=I\)</span>。由<span class="math inline">\(V^TRU=T=I\)</span>，得旋转矩阵： <span class="math display">\[
R=VU^T
\]</span> 当然旋转矩阵应该满足<span class="math inline">\(\det(R)=1\)</span>。如果求得<span class="math inline">\(\det (VU^T)=-1\)</span>，那说明<span class="math inline">\(T\)</span>不能等于<span class="math inline">\(I\)</span>。 <span class="math display">\[
\begin{aligned}
\det(T)&amp;=\det(V^TRU) \\
&amp;=\det(UV^TR) \\
&amp;=\det(UV^T)\det(R) \\
&amp;=-1
\end{aligned}
\]</span> 在这种情况下[3]中说</p>
<blockquote>
<p>It is easy to see what the second largest value is</p>
</blockquote>
<p>就是<span class="math inline">\(T_{11}=T_{22}=1,T_{33}=-1\)</span>，不过我没有看出来为什么是这样。。 那相应的<span class="math inline">\(R\)</span>变成 <span class="math display">\[
R=V\begin{bmatrix}
    1 &amp; &amp; \\
    &amp; 1 &amp; \\
    &amp; &amp; -1
  \end{bmatrix}U^T
\]</span> [4]中说如果是有点集共面因而<span class="math inline">\(\lambda_3=0\)</span>（因为此时<span class="math inline">\(C\)</span>不是满秩），那么对结果没有影响。如果<span class="math inline">\(C\)</span>满秩而反射（即<span class="math inline">\(\det(R)=-1\)</span>）是最优解，那么很可能数据中有outlier。</p>
<h2 id="四元数">四元数</h2>
<p>用<span class="math inline">\(q\)</span>来表示四元数。 由四元数表示旋转的方式得到下面的目标函数： <span class="math display">\[
\sum_{i=1}^n(qx_iq^*)\cdot y_i
\]</span> 可以<a href="#四元数性质证明">证明</a>： <span class="math display">\[
(qx_iq^*)\cdot y_i=(qx_i)\cdot(y_iq)
\]</span> 因此： <span class="math display">\[
\begin{aligned}
\sum_{i=1}^n(qx_iq^*)\cdot y_i &amp;=\sum_{i=1}^n(qx_i)\cdot(y_iq)\\
&amp;=\sum_{i=1}^n([x_i]_Rq)\cdot([y_i]_Lq)\\
&amp;=\sum_{i=1}^nq^T[x_i]_R^T[y_i]_Lq\\
&amp;=q^T\left(\sum_{i=1}^n[x_i]_R^T[y_i]_L\right)q\\
&amp;\triangleq q^TMq
\end{aligned}
\]</span> 可以<a href="#对称阵验证">验证</a><span class="math inline">\([x_i]_R^T[y_i]_L\)</span>是对称阵，因此<span class="math inline">\(M\)</span>是对称阵。 那剩下的就是线代的标准内容了，<span class="math inline">\(q^TMq\)</span>能取得的最大值为<span class="math inline">\(M\)</span>的最大的特征值，对应的<span class="math inline">\(q\)</span>为对应的归一化的特征向量。</p>
<h1 id="icp">ICP</h1>
<p>接下来就是不知道对应点的情况，也就是ICP要解决的。 这部分比较简单。既然不知道<span class="math inline">\(p_i\)</span>对应的<span class="math inline">\(q\)</span>，那我可以把<span class="math inline">\(p_i\)</span>与点集<span class="math inline">\(q\)</span>中离它最近的点对应。假设这是在第<span class="math inline">\(k\)</span>轮，这样得到的距离记为<span class="math inline">\(c_k\)</span>（c代表correspondence）。 有了对应关系，就可以按上面的方法做配准，记得到的距离为<span class="math inline">\(d_k\)</span>。因为我们做了最小化，显然 <span class="math display">\[
d_k\leq c_k
\]</span> 对于变换后的点集<span class="math inline">\(p\)</span>中的每个点，我们再在<span class="math inline">\(q\)</span>中找距离最近的点。这样显然每个<span class="math inline">\(p_i\)</span>对应的距离都只可能减小，因此总的距离也只会减小，即： <span class="math display">\[
c_{k+1}\leq d_k
\]</span> 这样， <span class="math display">\[
0\leq d_{k+1} \leq c_{k+1} \leq d_k\leq c_k
\]</span> 单调下降有下界，因此会收敛到一个局部极小值。 实现时设定一个阈值<span class="math inline">\(\tau\)</span>，当满足如下条件时停止迭代。 <span class="math display">\[
d_k-d_{k+1}&lt;\tau
\]</span></p>
<h1 id="附录">附录</h1>
<h2 id="四元数性质证明">四元数性质证明</h2>
<p>只要证明： <span class="math display">\[
(pq)\cdot r=p\cdot(rq^*)
\]</span> 然后代入 <span class="math display">\[
p\leftarrow qx_i\\
q\leftarrow q^*\\
r\leftarrow y_i
\]</span> 就得证。 由于 <span class="math display">\[
(pq)\cdot r = ([q]_Rp)^Tr=p^T[q]_R^Tr\\
p\cdot(rq^*)=p^T[q^*]_Rr
\]</span> 因此只要证： <span class="math display">\[
[q]_R^T=[q^*]_R
\]</span> 而这是显然的。</p>
<h2 id="对称阵验证">对称阵验证</h2>
<p>因为<span class="math inline">\(x\)</span>,<span class="math inline">\(y\)</span>都是虚四元数， <span class="math display">\[
\begin{aligned}
\left[x\right]_R^\top[y]_L&amp;=\begin{bmatrix}
0 &amp; \mathbf{x}_v^\top\\
-\mathbf{x}_v &amp; [\mathbf{x}_v]_{\times}
\end{bmatrix}\begin{bmatrix}
0 &amp; -\mathbf{y}_v^\top\\
\mathbf{y}_v &amp; [\mathbf{y}_v]_{\times}
\end{bmatrix}\\
&amp;=\begin{bmatrix}
\mathbf{x}_v^\top\mathbf{y}_v &amp; \mathbf{x}_v^\top[\mathbf{y}_v]_{\times}\\
[\mathbf{x}_v]_{\times}\mathbf{y}_v &amp; \mathbf{x}_v\mathbf{y}_v^\top+[\mathbf{x}_v]_{\times}[\mathbf{y}_v]_{\times}
\end{bmatrix}
\end{aligned}
\]</span> 其它都比较明显，只要证明 <span class="math display">\[
\mathbf{x}_v\mathbf{y}_v^\top+[\mathbf{x}_v]_{\times}[\mathbf{y}_v]_{\times}
\]</span> 是对称阵。由于 <span class="math display">\[
[\mathbf{x}_v]_{\times}[\mathbf{y}_v]_{\times}=\mathbf{y}_v\mathbf{x}_v^\top-(\mathbf{x}_v\cdot\mathbf{y}_v)I
\]</span> 因此结论成立。</p>
<h1 id="参考资料">参考资料</h1>
<ol type="1">
<li><p><a target="_blank" rel="noopener" href="http://web.cs.iastate.edu/~cs577/handouts/quaternion.pdf">四元数用于求解shape registration</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/121791">A Method for Registration of 3-D Shapes</a>（ICP原始文献）</p></li>
<li><p><a target="_blank" rel="noopener" href="https://cnx.org/contents/HV-RsdwL@23/Molecular-Distance-Measures#MatrixAlignment">SVD方法推导</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/4767965">Least-Squares Fitting of Two 3-D Point Sets</a> （另一种SVD推导）</p></li>
<li><p><a target="_blank" rel="noopener" href="http://people.csail.mit.edu/bkph/papers/Absolute_Orientation.pdf">Closed-form solution of absolute orientation using unit quaternions</a> （四元数推导的原始文献）</p></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/10/%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="demolpc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="demolpc的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/10/%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC/" class="post-title-link" itemprop="url">三维旋转</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-10 09:56:10" itemprop="dateCreated datePublished" datetime="2019-08-10T09:56:10+08:00">2019-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-22 10:58:57" itemprop="dateModified" datetime="2019-09-22T10:58:57+08:00">2019-09-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="旋转三维向量">旋转三维向量</h1>
<p><img src="/images/3D-rotation.png" alt="对应关系" /> 图中<span class="math inline">\(\mathbf{u}\)</span>为单位向量，表示转轴。将<span class="math inline">\(\mathbf{x}\)</span>绕<span class="math inline">\(\mathbf{u}\)</span>逆时针旋转角度<span class="math inline">\(\phi\)</span>得到<span class="math inline">\(\mathbf{x}&#39;\)</span>。可将<span class="math inline">\(\mathbf{x}\)</span>分解为沿转轴的分量<span class="math inline">\(\mathbf{x}_{\parallel}\)</span>和垂直转轴的分量<span class="math inline">\(\mathbf{x}_{\perp}\)</span>。<span class="math inline">\(\mathbf{x}_{\parallel}\)</span>在转动时不变，<span class="math inline">\(\mathbf{x}_{\perp}\)</span>在平面上旋转角度<span class="math inline">\(\phi\)</span>得到<span class="math inline">\(\mathbf{x}_{\perp}&#39;\)</span>，可得 <span class="math display">\[
\mathbf{x}&#39;=\mathbf{x}_{\parallel}+\mathbf{x}_{\perp}\cos\phi+(\mathbf{u}\times\mathbf{x})\sin\phi
\label{3d-rotation}\tag{1}
\]</span></p>
<h1 id="旋转群">旋转群</h1>
<p>旋转保持：</p>
<ol type="1">
<li>向量长度</li>
<li>两向量的内积</li>
<li>相对方向 <span class="math inline">\(\mathbf{u}\times \mathbf{v}=\mathbf{w}\Longleftrightarrow r(\mathbf{u})\times r(\mathbf{v})=r(\mathbf{w})\)</span></li>
</ol>
<p>1,2是等价的。1-&gt;2可由<span class="math inline">\(\|r(\mathbf{u-v})\|=\|\mathbf{u-v}\|\)</span>得到，2-&gt;1可由<span class="math inline">\(r(\mathbf{u})\cdot r(\mathbf{u})=\mathbf{u}\cdot \mathbf{u}\)</span>得到。</p>
<p>因此可定义旋转群： <span class="math display">\[
SO(3):\{\mathbb{R}^3\to\mathbb{R}^3\mid\forall \mathbf{v},\mathbf{w}\in\mathbb{R}^3, \|r(\mathbf{v})\|=\|\mathbf{v}\|,r(\mathbf{v})\times r(\mathbf{w})=r(\mathbf{v}\times\mathbf{w})\}
\]</span></p>
<h1 id="旋转矩阵">旋转矩阵</h1>
<p>算符<span class="math inline">\(r\)</span>是线性的，可用矩阵<span class="math inline">\(R\)</span>表示， <span class="math display">\[
r(\mathbf{v})=\mathbf{Rv}
\]</span> 由 <span class="math display">\[
(\mathbf{Rv})^\top(\mathbf{Rv})=\mathbf{v}^\top\mathbf{R}^\top\mathbf{R}\mathbf{v}=\mathbf{v}^\top\mathbf{v}
\]</span> 可得： <span class="math display">\[
\mathbf{R}^\top\mathbf{R}=I
\]</span> 即旋转矩阵是正交矩阵。</p>
<p>由旋转性质3，对于向量<span class="math inline">\(\mathbf{u},\mathbf{v},\mathbf{w}\)</span>组成的六面体，旋转前后的有向体积应该相等，即 <span class="math display">\[
\begin{vmatrix}
Ru &amp; Rv &amp; Rw
\end{vmatrix}=\det(R)
\begin{vmatrix}
u &amp; v &amp; w
\end{vmatrix}=
\begin{vmatrix}
u &amp; v &amp; w
\end{vmatrix}
\]</span> 得<span class="math inline">\(\det(R)=1\)</span>。</p>
<p>这就构成了<span class="math inline">\(SO(3)\)</span>群(Special Orthogonal group)，其中的special就是指<span class="math inline">\(\det(R)=1\)</span>。</p>
<h2 id="指数映射">指数映射</h2>
<p><span class="math display">\[
\frac{d}{dt}(R^TR)=\dot{R}^TR+R^T\dot{R}=0
\]</span></p>
<p>得： <span class="math display">\[
R^T\dot{R}=-(R^T\dot{R})^T
\]</span> 即<span class="math inline">\(R^T\dot{R}\)</span>是反对称矩阵。这些反对称矩阵集合用<span class="math inline">\(\mathfrak{so}(3)\)</span>表示，称为<span class="math inline">\(SO(3)\)</span>的李代数。</p>
<p>反对称矩阵可以写成<span class="math inline">\([\omega]_{\times}\)</span>的形式，即 <span class="math display">\[
R^T\dot{R}=[\omega]_{\times}
\]</span> 得到： <span class="math display">\[
\dot{R}=R[\omega]_{\times}
\]</span> 当<span class="math inline">\(R=I\)</span>时，<span class="math inline">\(\dot{R}=[\omega]_{\times}\)</span>，即李代数是在幺元处的切空间。</p>
<p>如果<span class="math inline">\(\omega\)</span>为常数，上述方程解得： <span class="math display">\[
R(t)=R(0)e^{[\omega]_{\times}t}
\]</span> 这称为指数映射： <span class="math display">\[
\exp: \mathfrak{so}(3)\to SO(3);[\phi]_{\times}\mapsto \exp([\phi]_{\times})=e^{[\phi]_{\times}}
\]</span> 还可以定义"大写的"指数映射： <span class="math display">\[
\text{Exp}: \mathbb{R}^3\to SO(3);\phi\mapsto\text{Exp}(\phi)=e^{[\phi]_{\times}}
\]</span> 如果绕转轴<span class="math inline">\(\mathbf{u}\)</span>转了角度<span class="math inline">\(\phi\)</span>，那么旋转矩阵： <span class="math display">\[
\mathbf{R}=e^{\phi[\mathbf{u}]_{\times}}
\]</span> 上式按泰勒展开后得： <span class="math display">\[
\mathbf{R}=\mathbf{I}+\sin\phi[\mathbf{u}]_{\times}+(1-\cos\phi)[\mathbf{u}]_{\times}^2
\]</span> 这就是Rodrigues旋转公式。推导过程用到了 <span class="math display">\[
[\mathbf{a}]_{\times}^2=\mathbf{a}\mathbf{a}^\top-\mathbf{a}^\top\mathbf{aI}
\]</span> 根据这个式子，又可写成： <span class="math display">\[
\mathbf{R}=\cos\phi\mathbf{I}+\sin\phi[\mathbf{u}]_{\times}+(1-\cos\phi)\mathbf{u}\mathbf{u}^\top
\]</span></p>
<h2 id="对数映射">对数映射</h2>
<p>从<span class="math inline">\(\mathbf{R}\)</span>得到<span class="math inline">\(\phi\)</span>和<span class="math inline">\(\mathbf{u}\)</span> <span class="math display">\[
\phi=\arccos\left(\frac{tr(\mathbf{R})-1}{2}\right)\\
\mathbf{u}=\frac{(\mathbf{R}-\mathbf{R}^T)^\vee}{2\sin\phi}
\]</span> 其中<span class="math inline">\(\bullet ^\vee\)</span>是<span class="math inline">\([\bullet]_{\times}\)</span>的逆，即<span class="math inline">\(([\mathbf{v}_{\times}]^\vee)=\mathbf{v}\)</span>.</p>
<h2 id="旋转作用">旋转作用</h2>
<p>将<span class="math inline">\(\mathbf{R}=\text{Exp}(\mathbf{u}\phi)\)</span>作用在向量<span class="math inline">\(\mathbf{x}\)</span>上，得到： <span class="math display">\[
\begin{aligned}
\mathbf{x}&#39;&amp;=\mathbf{R}\mathbf{x}\\
&amp;=(\mathbf{I}+\sin\phi[\mathbf{u}]_{\times}+(1-\cos\phi)[\mathbf{u}]_{\times}^2)\mathbf{x}\\
&amp;=\mathbf{x}_{\parallel}+\mathbf{x}_{\perp}\cos\phi+(\mathbf{u}\times\mathbf{x})\sin\phi
\end{aligned}
\]</span> 与式<span class="math inline">\((\ref{3d-rotation})\)</span>一致。</p>
<h1 id="四元数">四元数</h1>
<p>旋转公式为： <span class="math display">\[
\mathbf{x}&#39;=\mathbf{q}\otimes\mathbf{x}\otimes\mathbf{q}^*
\label{quat-rotation}\tag{2}
\]</span> 由于 <span class="math display">\[
\|\mathbf{x}&#39;\|=\|\mathbf{q}\|^2\|\mathbf{x}\|=\|\mathbf{x}\|
\]</span> 因此<span class="math inline">\(\|\mathbf{q}\|^2=1\)</span>，即<span class="math inline">\(\mathbf{q}\)</span>是单位四元数： <span class="math display">\[
\mathbf{q}^*\otimes\mathbf{q}=1=\mathbf{q}\otimes\mathbf{q}^*
\]</span> 这与<span class="math inline">\(R^TR=I=RR^T\)</span>的条件类似。</p>
<p>还可以看到，自动保持了相对方向： <span class="math display">\[
\begin{aligned}
r(v)\times r(w)&amp;=(q\otimes v\otimes q^*)\times(q\otimes w\otimes q^*)\\
&amp;=\frac{1}{2}\left((q\otimes v\otimes q^*)\otimes(q\otimes w\otimes q^*)-(q\otimes w\otimes q^*)\otimes(q\otimes v\otimes q^*)\right)\\
&amp;=\frac{1}{2}(q\otimes v\otimes w\otimes q^*-q\otimes w\otimes v\otimes q^*)\\
&amp;=\frac{1}{2}(q\otimes(v\otimes w-w\otimes v)\otimes q^*)\\
&amp;=q\otimes(v\times w)\otimes q^*\\
&amp;=r(v\times w)
\end{aligned}
\]</span></p>
<h2 id="指数映射-1">指数映射</h2>
<p><span class="math display">\[
\frac{d(q^*\otimes q)}{dt}=\dot{q}^*\otimes q+q^*\otimes\dot{q}=0
\]</span></p>
<p>得： <span class="math display">\[
q^*\otimes\dot{q}=-(\dot{q}^*\otimes q)=-(q^*\otimes\dot{q})^*
\]</span> 即<span class="math inline">\(q^*\otimes\dot{q}\)</span>是虚四元数。令： <span class="math display">\[
q^*\otimes\dot{q}=\Omega
\]</span> 得到： <span class="math display">\[
\dot{q}=q\otimes\Omega
\]</span> 当<span class="math inline">\(q=1\)</span>时，<span class="math inline">\(\dot{q}=\Omega\)</span>，可见虚四元数构成了单位四元数球<span class="math inline">\(S^3\)</span>的切空间。</p>
<p>如果<span class="math inline">\(\Omega\)</span>为常数，上式解得<span class="math inline">\(q(t)=q(0)\otimes e^{\Omega t}\)</span>，这就引出了指数映射。</p>
<p>如果绕转轴<span class="math inline">\(\mathbf{u}\)</span>转了角度<span class="math inline">\(\phi\)</span>，定义“大写的”指数映射： <span class="math display">\[
\mathbf{q}\triangleq \text{Exp}(\phi\mathbf{u})=e^{\phi\mathbf{u}/2}=\cos\frac{\phi}{2}+\mathbf{u}\sin\frac{\phi}{2}
\label{quat-form}\tag{3}
\]</span></p>
<h2 id="旋转作用-1">旋转作用</h2>
<p>将式<span class="math inline">\((\ref{quat-form})\)</span>代入式<span class="math inline">\((\ref{quat-rotation})\)</span>， 推导可得式<span class="math inline">\((\ref{3d-rotation})\)</span>，这就验证了正确性。</p>
<p>在证明中有一步<span class="math inline">\(\mathbf{u}\otimes\mathbf{x}\otimes\mathbf{u}=\mathbf{x}(\mathbf{u}^T\mathbf{u})-2\mathbf{u}(\mathbf{u}^T\mathbf{x})\)</span>用到了<span class="math inline">\((a\times b)\times c=-a(c\cdot b)+b(c\cdot a)\)</span></p>
<h1 id="四元数到旋转矩阵的转换">四元数到旋转矩阵的转换</h1>
<p>由 <span class="math display">\[
\mathbf{q}\otimes\mathbf{x}\otimes\mathbf{q}^*=[\mathbf{q}^*]_R[\mathbf{q}]_L
\begin{bmatrix}
0\\
\mathbf{x}
\end{bmatrix}=
\begin{bmatrix}
0\\
\mathbf{\mathbf{R}x}
\end{bmatrix}
\]</span> 可以得到： <span class="math display">\[
\mathbf{R}=(q_w^2-\mathbf{q}_v^\top\mathbf{q}_v)\mathbf{I}+2\mathbf{q}_v\mathbf{q}_v^\top+2q_w[\mathbf{q}_v]_\times
\]</span></p>
<h1 id="旋转合成">旋转合成</h1>
<p>四元数和旋转矩阵的合成顺序一样： <span class="math display">\[
\mathbf{R}\{\mathbf{q}_2\otimes\mathbf{q}_1\}=\mathbf{R}\{\mathbf{q}_2\}\mathbf{R}\{\mathbf{q}_1\}
\]</span> 这是因为<span class="math inline">\(\mathbf{q}_2\otimes\mathbf{q}_1\)</span>作用于<span class="math inline">\(\mathbf{x}\)</span>时，是<span class="math inline">\(\mathbf{q}_1\)</span>先作用： <span class="math display">\[
\mathbf{q}_2\otimes\mathbf{q}_1\otimes\mathbf{x}\otimes(\mathbf{q}_2\otimes\mathbf{q}_1)^*=\mathbf{q}_2\otimes(\mathbf{q}_1\otimes\mathbf{x}\otimes\mathbf{q}_1^*)\otimes\mathbf{q}_2^*
\]</span></p>
<h1 id="参考资料">参考资料</h1>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1711.02508.pdf">Quaternion kinematics for the error-state Kalman filter</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">demolpc</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">demolpc</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
